<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow, noarchive, nosnippet">
    <meta http-equiv="cache-control" content="no-cache">
    <meta http-equiv="pragma" content="no-cache">
    <title>Xavier Rivera-Lanza</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; }
        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: #f0f0f0;
            color: #1a1a1a;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .lock-page {
            text-align: center;
            width: 340px;
        }
        .lock-name {
            font-size: 1.1rem;
            font-weight: 600;
            letter-spacing: -0.01em;
            margin-bottom: 48px;
        }
        .lock-card {
            background: #fff;
            border: 1px solid #e5e5e5;
            border-radius: 12px;
            padding: 40px 32px;
        }
        .lock-label {
            font-size: 0.7rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #999;
            margin-bottom: 20px;
        }
        .lock-input-wrap {
            position: relative;
            margin-bottom: 16px;
        }
        .lock-input-wrap input[type="password"],
        .lock-input-wrap input[type="text"] {
            width: 100%;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            padding: 12px 40px 12px 16px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #f8f8f8;
            color: #1a1a1a;
            outline: none;
            transition: border-color 0.15s;
        }
        .lock-input-wrap input:focus {
            border-color: #999;
        }
        .staticrypt-toggle-password-visibility {
            cursor: pointer;
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            opacity: 0.3;
        }
        .lock-button {
            width: 100%;
            font-family: 'Inter', sans-serif;
            font-size: 0.85rem;
            font-weight: 500;
            color: #1a1a1a;
            background: transparent;
            border: 1px solid #1a1a1a;
            border-radius: 24px;
            padding: 10px 0;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
        }
        .lock-button:hover {
            background: #1a1a1a;
            color: #fff;
        }
        .hidden { display: none !important; }
        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .staticrypt-spinner {
            width: 2rem;
            height: 2rem;
            border: 2px solid #e0e0e0;
            border-top-color: #999;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
        <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="lock-page hidden">
        <div class="lock-name">Xavier Rivera-Lanza</div>
        <div class="lock-card">
            <div class="lock-label">Password Required</div>
            <form id="staticrypt-form" action="#" method="post">
                <div class="lock-input-wrap">
                    <input id="staticrypt-password" type="password" name="password" placeholder="Enter password" autofocus>
                    <img class="staticrypt-toggle-password-visibility" alt="Show password" title="Show password"
                        src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==">
                </div>
                <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked>
                <input type="submit" class="lock-button" value="Unlock">
            </form>
        </div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "Wrong password.",
            templateToggleAltShow = "Show password",
            templateToggleAltHide = "Hide password",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8f8fb306ceb02ed266d96854d0daf272d4d92f7faef9702b14c0fe41659bd29a1030790be8ca49aeb574434633a1746280d5f0de1766e186df67095a96260c5217cfd13da5ca7971dbd838cc7e6f277215e2ebeacd594f5d86afee231b191804aa8d041dd8c3043577dafa2ce1c37b17e7fc46f9ab03ce21c2f62cec153eae94bcba141227b1a47ed830828be3ea33a00127339aa8c99f9df88b8e7e195e383f188fec938507c45d54eb618143c6ce5fe1dca624183f2fed32353150d68ae67b0f07164fbab0d3c2b7942aff990ef6fac6a3e2845209546bb0ecf774c1ac90e769d32b6d84689e61604c8c3911cb10bd5a0f987359cc858de75a7b2c6a21c8dbf995f130ac68f2d400074d2000875ac158841cb05000325f7964e226416e72accbfef5ccfba7ebe059705a6ded39952edce1f709e2e99a2592a87524d3eb6b50aaf13336be5986cceac2e2281e03ca67bf115ded882116b454f7cf9629885ed67b2b03c8348d72dc515ad531bed68cc0f569035c8f2c3f4aef13aea6027f27660362a9a113c78ad9e86a1a3e4f194bff0a5ed32189d2b731927e423f106a58acf9bb5a989872f15368fd0e69fdb6b9523e2ca2c9e672f3c3bb23c7a7885a7671f55b93177eb69a262d6309e8bd706f87d3a3e1d28d4f8f1a46d7b36f7fae815542c74944f1435cab46753ed8173189ff7a555cdd28b72d140afc58afa9ea0ec732161382e5148ca1b09969958f6d27566cab7f205a457996e19812975a09434776dddcdb8c3130f656af83282692e7ee5fce0f50551c5e0001fcb91877e2b641a207fedc62b8d1582abd144db7c10997b0a3fd69b589db3d36d5f7f2994759fc93e41fb3eafe4799ec4b352ceab2a05b404d81ba732802fad613135ea7da5afee95e7c30f670b2bea25573c920df14ca2b8574a6573d17cb28aaa8f11e2cd76623641c7d22a7ddde533d05814b108edc261e40b81c74fd57a0c936eb46751481a3ade86b2e20c208b688b3b89326d36f3bd8e91f2ae9206ac56492009b7941a61729b61f246fcdf28e587fb01bae1c54ce67f3dd7bd1fcc92e843927f319294b5232944b82e4085043d5b56cc12f9fe6a5938aeb0e615d1efbdd3d8cac666e8c1f842f23f8c3db4f264699332427e946070289c915a7704157d86aab24eb6c8d113185578d9e825218e7db2d9ac96ca469524828a1f694fb3413837ceaf4a79f2ad239f625ca730942deb10ab41c86baf61b65703c1f63d25dcebf02fcb4bd97e33c3a8104636f1c1cd219960f27f466584989606f52dbf74ac04e9f59b08293a8eac8c639d144fd5964f4681fbba08bb600675810a2f0cde849b26f0b53d1f56b1af1d6f600c0e50c81a238b67e5771a11d57545c0e4aff6c9601d12b20b09e756d2b4eaf561baa1fd52c0e17c7d53799f8b76dc590d0d356dbcff6d0692ec442f9f5f02b0b34bfa47e3974017cc8af32743040a451b588d432b82034418ec70986d483555a99872f729309bc36745a0ad47ab1c86af000cc90047a659884b1621ac55722e519bef0595f624bea437a6c1f8d4b475dee26cb47b98e9bb02cd719fb79e5de06e288d91c02955f5465b8c27b3aa6b4f8cf6770be0c6bf5dd80bead555efee1923629e9f2df931f631bd79c851b5d617745fe5d6d079c1bdd98beb6df654579c7e2fff72537089da9e5d63790d15bb9ec2e53a3e5714984011d8c9f05d253f0206256e6cfd12cb4839414bac18fdbdc3460a57a05213e84580ffb325ee9126ca0dbabc119d222ab95248dd6ce29083b10fd7532d20afd90818688ddaa4a9a2a21e999003c107cf246e0b98d9a4a2a05e9e531dd39a97d87ed1eeb4d90b86fd5cd36eaac82008eb42c9119e4baf4aeb8b545a5abcfbad8b5659b1f32cad2add44e7f5d5431aabbd8564db471a09f7e375ca1c469667e854b2f2630e9de68c55d3a538a53c4c6a3f4e7e0aa76151d3286d0266f42db03469c73fd5b0afed08519d72d9683e1092ad08494ad8e5cd80306fcc032b34e3d38d2bf695b6ff0799ffcaeab91bcde35d7bd08a2908119558dc547161aed8ecfb2c89302d9691ff5ca6200f8fbe5f491831da23dc215bcf3b02bbaef5d0949da2d7140b58aadb8923ebfb65760aa48015455bfcfc3bf19709bc9f79cbb7b9ae0315a02b28cb2989ff8577a400b0a01f5ee642911d0660c192c25996549e069217e3d622b66cbccb87e247313c951f66ea9661103c9e1d2141b5a08b9718ea2735ea955f14ebf29162e83ebc11afde99b9ed4073ea12c91369866ef67908df7fe382b28899a167ec5f7274284a4439bce79f968828fe0620f3534c8d4ec2f14f1b10c7e46d12cc0487022d71000e5c28eda5f2f1da60dc551b573d84c3b4a4dbdf1467be2dc7f14a878514f58e7362e904756aa72fbdd246858a5a9c2e29422a8f9612620c3f45ca6a6a3e4d60576bf15b8157844ba9a65944f51981fbc25a405ce0f053eb43c8c15d32985cf004c6afa80cbca7700c9c625254021f0ea49f25526ef62b4cfd15958574ae6d818bc6aa12ebce6d2246545cb11849f945b9391058ebf434491ccdc5274faff94b9325ee2804fac73433097106ec4ffaef675816ee375378edd276c0a6c46837befcccc5cc6e879496fa01ffa6c162da2d5811e111730a8a74203aceadf79de2b7ae038436606faee4e9548d56f12179043201cb89677628fb9fbcf5c2f4ebf78ae67876ef3311a31fc3816315f90959ad83e993b7c411c890241e64b4a16725ce93a6fbcf4c8360c1059914dcd87817bb9a47c6dfaa9f330724c77ed8e3d1534a2e64b2b1446f561cf364248e8a1082c5738e85e1dc3b817b4df1a12989cba22e9f625a9aa21afeeb77945f4127df24521ad3ff231afb287197796b9a17744cb5df76a0ef9332b74fbb8aba74e2cdcb101e50c5becf4c599ac853899a738eae21bb95899a70d69fa9271345929c5ba8dd24ba103f47e23734afe9fd038b4ebe4b83928e73545bb5653b2aa8efac3a7c564bae704424e044875349a57658ad73feeb58dbdf698ec7b0f459bbd66d56f9e5bb73ba97de7ad29080641efc189b3bd7907d5737c0f2e1e7eefaabefe085f80eeea65bc832f3b6cf69342b8c7aa761541e08932da7fc0644afe4a510ed32ed50396a987145da896b868d0829c2b0d0aaa0f758f612720654b7e3ce13f0df89398229be4b55715d93ae0abb90ad949af59b0bd7e15e54bbc1830390ed43c37ea1db7a061593372ed674f1163715ec1a2243d2ebe96a0e0d4a890c5f928a2e80020bff4dd6e9d4f4858b5fd58c106878b430bb71fa5c40356b2a458822176be998d9195bca8d0a041801613b187027da76af2da905b447268e6d3c4f2f05c0ef8390f278a89ab509365ea9321c51d70e8b49096cdebfbec3990b5f8520a205414cf32f72e8ce036e231d2d657ace9194b97436216f28985a5dd535255181e82bb530151f63cadf30182bc1f31c21d95ad9ce7bc97e41490bb546d9de400917c0bcaa23cde9e28685ba5c248f5b5377fee38c61ee4bb3ce7a573d2ad70172dee9afa76d9f1850b36fce1447d77e87839c2184f80e21b30bf4d0b0ef0724bca0905dd1160c3d5abae10bcc91abcfbf242c0f28dc4463f1e4df2687c1a2a4b8dc67893d7262fd82135153502a124d234154eb63742afd61965b0a2277cec7dce5a34b706abb1ad6e68f4b7f07cc8e3ef87d56e745b09dcd71bf8ab5be990fee671979c98ef7b6bc050563258417fed686f79ce30dad53e26384e0934e5ba9575e5d19440d546182780966a676bd0e2541e2b2da91077dec0e21ad3b0dc5056fafc32c00ff3c4f5548c6bafa7579c50a557a2e631b5eda22dce89b07bd304b226a5b76cb54fa4290326f4c190ac98d0256b15f0c24f20c111062962d12c64cf9fbc09d9d1f3dedf1fb6f12b455e360a9b74746cdc9bd7654abc3a272c28effe03fa53eca7da076913ac012df89ea3339565b79b5e4cb8a8502e2363496d12fe5dad84c09250d1f7eb3c9cbb31120f803bd4ef7551ad65fd95fba736b485fc98f57dea8bc952c8af200feb0ec09b91e1a4b4a29299b9329e3f99c031a03a7efbc5e647bca60be148dc06bd9f61f641d38166b31960869c39a7117c407d3a693e2f6221ed1c397c98b420aa06771771a0c43654fc6d12300fa65d1b1599fed87fc5886e8bcbe2c7ebe32422f0f97b5e2c62292a908a5583c063a23402f736f57ebc4f9fcbe5a677185861a933bcccac544900336fc7ac9e4a81981a8363723fc1df832ffd063f74b2db7b570166fc1cc98675ecc6bdb58c9c3588d1b37cb4a371d5f175c6beaf1db03935343c59b67b354749532706ffd85f1da55a6491c8f12d94575e7ba1194f2768d923e9486c37c52453db8d77f8a1ba7793f14a1d782412c18a2458b1ba22ac05bb2b88ab565d2f5a7846ba4867abb8c051b0c54157c30ae1b98411a1f141d67d6f920ea813292450bc18e4de6059db44514cb91628564c74a49ad37111e12b6f586beda106a98070eaeadcf7664fbc84a297854d5e5ea1b667fe31d063120c9a6313237ee33a64ed1103c595268ac82c3affa7da0bd00482597837d45c25b5cccbf73288ea10904fceecafc3b19d90b57172cddc5f3e49c4c6f3a343fb5c6ba05dffd38d8b9fc1b33270992db83716e9ac4fd3deb34943d26921d263ae5968b7187b3d8afe115aa7503246f35d149d655b2e25a1352966df49f4572ac4b39ce49f1d4f041b6e655762199452b1daab32a042cdc6f50d77a585b8229c627bb5cdf404a78f48425d0060ba01b8ae7c62ec4a5484e097794b06feb830c20ca31e24f7b71201cdc166c7fbc571aa41d2f0dff2069b0beeb0f0bb41a100aee472e24fc900b30238e0c4fe6a849bb698738bb49f3e2b099f14d0aaec2496368db7fdf9e18ae7c715d6099afc2097bb053b2c4026531a45cf2a2a72a119eefc9382c5a6ecddebd656610155f32d3e7f42328000f5928838ea8f19f8cc7d3d5f6a760a23e1f101b97a07ddfb6c327e88311b8b128b8d58ea243bdd61a97713c5ff08952a2b807a26106c2a9b4956513ab26d9f77c3e02545b34e189da310e0391a917b67d880842120e17ded9fc156f93eab59bd8109ef06bccab3417507371bfc638594bd353635960abdfb3b69d61d7162bfa9126fc43571b428b59b6cc7e121b25e27adc96616075f6a72ade33d645c0c33cafb4f983db071fbfd30da3683468f7a198f0558c069cfe4a8e36dd809098ac910f3824efe8bff6ca06de34725dd5e1f5157aa77dadd7f13002dda3be910eeb5d13e21c9f0e4bcbe5c647e49285f8a9c6cae36b55f7ce4026a81a4b907d874989bb599ae18759f6b57dc9e397ff2fd9570b135726ddc6e9b52828ec01bb4b8346a99e8237ba260136cabdebf7403ff748f38a3d8c3dd5bcd49e6f8f12205aa6ead61c460a20c58c46c2050308d61a95d53b1f60d851942adac5ced9d72c3fc247f6c699eccc465ac12f33585cb167142babd2018eecee327af54ebdc5171057adaa7eff3072364ab69043db7de217202693ab9a0ebb134a0c3c9e776979fd3e3731d0e26b4418fb8ce88a90f1edaba3f80a87677565d4c96ef800b479e87b3210f1ffb05625509f409e496a0ebc3aef58ec4b5f184f8f715fe57037ef37a302e46c4c1ea440f4296ebea571e4007dc35e53ff1552b70174950b5085cf958eba297fb2103fe9776ad5df9f6f205fc9d7e26b9f72570431a5e19283137678fa456bf71a09a79326fdc5a12acc5631317b38cce33a8e8b6d68392750b7607c1ec89d7f837487f5f62c7dff8d0df20dcfa9ddfef9ba685a2453ff331f804073f25e80f857bdbd88d9f4d08f2a2a4cc1b701945ea81766194c2f27d735c0bfb74ae3556da4374c2fbad60b4558c6043c303696b129720b08afd72a7b55bdbf497c2d26ebf8a9f8054b8b9e5085713a9329991490bd7dfd97b2b04e33b5974069a54acefcba2846187d43f75a7bddfe013b82bcda7e80df6225e6355d0329f0fee94a8be151be3c42e5604dcc17b498cdc582bb1e9de69d21d6a7a37a33239ac9eab609889655f606f1448a1432bc3d7d96f7b671ab8f36952490059005983cef4ea3195926e4822239332ffc7295083e0ad9951a45ec8013182c557c8b04c518839f227e09ff3635c647c82d1a8ba425632e68aee82636e1ad6680f5d620d19677a961c29d93c1de1fb98dd7cbd009f75b18eff8dce6e15e38b77a1877c2d0bf5ffeb96808668d5beeca71bad5118bb56ec24063679197eb4433528d02a95e4fb128ae30afb27943b099bf4551ed2db45631966748c7fe3eebec58781306311f774f1b69b43ab5f955db3d0dba03acfbb138fe881e2708c2c120f86194d8bafd42aa85263876faf8b0de93594d74e28aee24148deaaccc14495a58839d09105a1225b28bbd89f70cbf85d36e9d64ef1c4c997d593d6925fbc2da81110d86a4f565d124d13cbf49c947679fed463d08b1ad000a141c1cb050e613f91194d78eb9bc047aabc5e1683cabf03cfb03a41f027899d6556c5a87e47c13ec47a41b29a640af4e1066ab5680d8efa1272c2aeea994db93d7bf7bd15998f9e71c9d15c01e89341423fef8d56c8ca48bc705e912efc1806ee864ff6dbab11f8e659270cf723c300b95b3aa18a5f3eb5b1f182bf596e26ea7db2f38ab9a7f4cab64f5484ace750e41db53a54a962472341bbf3e86538f5b73d4d53ac0e81b309c4425fd474458d066b92ae4f4d317c0787729862e3c676ba13472f40aacde2951d57234dc339f772ad404badef7f6642b46f96e9420c577761cf7ad15d348d9d77e5d9cf6b584336578c99f88b7f05ea274275062b529f401b57995594f3ced5e578edc9ad0d2b5136462321abe8bfc840544ea7f9472fa399d19fa4153987f3c5fb668379f5daca1f2fe2b762b8a1b975a7d97d15e22c23d7cd9c200f33ba4975af20fa6d3a5bb96e26205ae1693a6f19defd86e60d78bc4c29c1f1344463e8ea659598b696d678397241f6e720a0bf552df8601e5d26909c9d16fa17719df4a5617b712e493aed33295c269774d48c74737f0302865a4a3112131a55ec1ec4a5ddcb89fc8492819553c134625df118619cd76ba7738b2cbcabe5bd52b48b098c4a2adc69ebb43e3689aae775e5325eb8a8513552399481cd3ade20e1750e22c5f8cb8fb1775191ad1908bb5b71f1aede9bffe3d4ff0ddefcb6264f7ddc4bb5d68c30f2823f62eee3b7f9ff1d884638e98ce77d63afa9d9f833219fc0d091953239aa57fcb0d7b5546ae7988bd62efda5b1b9836bec4d1a7a1846faf3606dd6d389b77388b7119b24ec20a033bbbd633082323a49e29c46b8bc05a8675cbacea3828c3ed7e522275405816d69860eb8265bc6c06d6119f62c5ffbf357324f3a357f1a48cac915e781de83e1220b9543ec7d6dbf2d5a4e66c212666f62e700b59cfd16c84c4d96cb9d88011397f8240ef8e58f709cd5c558f64e70d18fd1eb715d559897781553b5c664123b14bedeceda2b183b561f18ec5d5d54003c79cb83a95e2ef9fee0bb48d63caf8801dc2dddf3f15de8d19d00c49fa48572653d3f98f3964c8c099db333e33fe96aa826500ecc02b901e5841ffd2cae6ec5a7b21415047bcb75a9c9dedd6ed3d23a22a8223c90f3458f8f3612a853bbc48a7834dce115d36eb80fc05a1f165dc9b9452c8b45ee0eea6d5c3d4eb2a95834be4d2626746aa09418de325e091457a102f80590e4bcc7f69909236d23a0f6e1c773c1afa4e0314cb626436e5d731487c54dee3968f25a6e932bdd17ab38a0ad5013424d625303905d9f09e4edf9802b4e6ec348c566754ae41859fd5067841f0c2e3c73eb5377779a263117612ccd43234f4f0ac332911076e26eca4df72850436d44669f9816a4d15b7db42a29f40ca766d003a1ed21fe2116fab7577fd4ac5aa9fc203e1ab991e5d7e5681c0a4e52699e8ac21e56071e8079bd9361d8665ea3598462c6ec079f3a1d6b7c6e672d15ef70f6e41fbb3a68853f69dcc59488899584b6efe78e684539107b42b3952ebd19fac5e2d4bab5f93d74b733f36491c013540b5989ad393a8ecad61b6cac9deebe8c664b308aa2e5ba7cb0298343289bef7620f409fe4bc8c552a197e458f09f00f23ecd3bea6ba4f533dbfda6a1cd56696d4c9d30e7b7fd9865701f54e5b9f21e6f01c26b1594ad9a1880631be4b600d8cca752582367e323d53495be460a890e6e62cb283b4c5aeff9fe0f295f21a1bf5fcee804a6d126c070d61cea0e462a101b193a00f69dd0e730f37c8b5f9e51ead15eb226c81eaa44480dd1ced416245e1f8ebb513ace55d422b408c523be46c18f5e5fd7741bd224764a4def6704b97de79048056a8648de9fa50312d9fe13c6458743ee675641a26c15f18a7ac94faf940d7a7cd36a60f0bd567bed07f970372fe5a1c594342a4297b43dfcf1eeb2df304f2298793173069f807d044ad50ab640896378f7b1d67de2a3cd3c46259c5dd03f86b7490998548d8a873e6486980208bbaf3c57b64975ad92d3466f9bd8bcfce1cbc1b16a5e6fa393949b6956bc29568d06420cbd00836a7e4d7656608c964f89bf41f7ac1dd8378ecc29564787ac88ec17bab2c380105a378309f2942b8efcc6243dcca905199068fc2fe0e9930c4782f5dc5b114a8a236a44fcdd8fa573907001bcbf27e58c1606326455fc2a7ea490bb40ef5b6d0ea67440e74aa2f012a34e3137a701c7036f25f5b99c89442c0d90bf74fb675477d86b69fbc51f366c5beb0cb9118d2a2410d16f82dd7521335da04de8ed314e6359ccc025b9de02fae6b7ce81e08a8d66c01d0ca54c28309ce777f2ae127bc1ec98bb4f10cb855ed97161d411ab4797a73425188c0fb922024e2fd62cd96a95c97032c21389e7014f9baaadd5754f19bf8921352c07e4af0aa11bbf5c33008daa7a2a7c224d25aebd4fcdd3cc3e0aafe76827f765b02dcc720d8e0d5de181da730f1ab378c214a99b7596ee706f87ea0629476e658426c587abf1bd75d4031ee88dc96434088b29b8d652d7925c0ae3a193e01362040aa559a5441b4ad6ad74cd938ac98a07fb7afb1c6c7f9727b994e0b0f973ab233086f906c6b812981eb116b026ab2703d9ae8b336995eb627557d97571a4c5f8d3e6dd8e6153001014ce8adcf80aa867900c7af5fb66f551500f1b4ee144fe40cdb135a5b2ef7c14c2ffea0930e35a76e5482bea85d30b72e6819010df1593def146db2faf4dcec9c363e295227d486eb414a53e699c72074e122490033745a70ebfb2cbab1e6da27aec3da843bb2f438e8c9200953cd5d9869f28e1623a67b4ca4cd93c233b1f29e71c30667907e56fc8ca3da3f37fe376299a2f9c27e163c0410b05e7300f4d97a3e6ec7e69d9fb64352668ca910f1853e7350d0c8f57edd39bb7d5e31e0f78a54ccc3adc2b77bde5cab9b281f69af695099fd86579cb916339727dcf670673e2cbd8c8fff5b17e47493be171b981ff0903abb4e85d08326248c95022a241976972254d7115834627866828a1dcad1ef92f8272583dfec23a69cd8ba755844905f162a26f375285479946c5617d2ee5643c2c2202fa08cee7dbcceb8b8e22b5ee3be396721d7b5c22c5db78e0eb03abfe7430ff18c6527222d9655763dc1e6d5dfbfc7a02277cdc097c8560638bf830ffe05850fc10b781f369079453ea380ca6bfe32073b67a4defba299dde96c3a4c931d407618045c332f868583e3d60d0930aa5e6ef4b798b6b1c0b28e0cf0c85010e5b24b4ddae136bf0dbd8e7c9bdae263428da88ecfef3f18f149159433f774e19474b751d32451c5387fcea9435eed992feb933a1431a8556ed24dd0d38cf7c7feeca10473fbc36cab07f8a24f1694dcd74fc33531af32b4a5340151d757fe6245ad46bf821df0929fd69efe171f29359e176aa7f819129c86c51f7073a07a07237d8acd9580566c461c4d8309d3eeb33a135aadce0cd752af100db1d8d3c7eaa4f617c5109d8afb076292c86fc2fcfce973a88f03a5de3b29028287fec752432f3f14c8489778901593ec5e936ca327924cea40dc8ebfc024a465c9d987af31573a3733dbb91cd25eb59cf5ad23f8ef4ad79902d5f0e1ddd6044585fbc3fcd7a224008fd1b1d1b5e34cb8a83ee488cde6ecf03c6974ade93f6e76adfe97d206b5ac1c16de7b5083c03717b0c89ece4b1b7d2dfbee62dd3d01b0e52c7f100137b8c387f6338aef19b4d34d3c611da4a8a4550b9fd557de5529ce3f4e3a71f0e3fba94cfec30d6b05ee0a5239b9ccdac020f4699fa0eb55c36acb3c6f5761ae960118ad51e1ca0d52231f2b76652bcfffe9e0b98fa224d00fb5b44ce05683417de9b723715d480764bce2162f02fabd68aa6467d2a76c0d56c0bd7821532b10bbcef6f3c4bc0de21f7570d5ce08779fa8e55d5067bd6925b8302a95669f589aa9d2f7ec46454b65cdc61d27f4a98b544dce0f28e142a160a09dbc979feedb391f995e750303663547b92bf45ab29e1b138f9a5d22aac4033fecec85b6a6b864dc54b91ed33c005e9e7eac50874154df75fd514741eb23dc2c04c20ec1288c0549da328b8908f50688678452f4ee5bf561018210a5e3bcab22a31a0c24bc6a338e3e81b704a0bf6612190977861dccab61bf93e01f2b7aaee727f2b13dea464fd1a39d09421750b02eda40669b4c0b8b4fc1a036d7625396e5c722ebab05ff131d811a352eba18fdaaf80e2","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"3ce507516cc56ec0fa738732f387e94b"};

        // Use default document.write (no blob URL) â€” keeps real URL so links work,
        // and lets Staticrypt's built-in localStorage code run after replacement.
        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
            }
        };

        const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
        const imgSrcEyeClosed = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
        const imgSrcEyeOpened = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS4zIDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
        toggleIcon.addEventListener("click", function () {
            const passwordInput = document.getElementById("staticrypt-password");
            if (passwordInput.type === "password") {
                passwordInput.type = "text";
                toggleIcon.src = imgSrcEyeOpened;
                toggleIcon.alt = templateToggleAltHide;
                toggleIcon.title = templateToggleAltHide;
            } else {
                passwordInput.type = "password";
                toggleIcon.src = imgSrcEyeClosed;
                toggleIcon.alt = templateToggleAltShow;
                toggleIcon.title = templateToggleAltShow;
            }
        });

        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, true);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
