<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow, noarchive, nosnippet">
    <meta http-equiv="cache-control" content="no-cache">
    <meta http-equiv="pragma" content="no-cache">
    <title>Xavier Rivera-Lanza</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; }
        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: #f0f0f0;
            color: #1a1a1a;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .lock-page {
            text-align: center;
            width: 340px;
        }
        .lock-name {
            font-size: 1.1rem;
            font-weight: 600;
            letter-spacing: -0.01em;
            margin-bottom: 48px;
        }
        .lock-card {
            background: #fff;
            border: 1px solid #e5e5e5;
            border-radius: 12px;
            padding: 40px 32px;
        }
        .lock-label {
            font-size: 0.7rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #999;
            margin-bottom: 20px;
        }
        .lock-input-wrap {
            position: relative;
            margin-bottom: 16px;
        }
        .lock-input-wrap input[type="password"],
        .lock-input-wrap input[type="text"] {
            width: 100%;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            padding: 12px 40px 12px 16px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #f8f8f8;
            color: #1a1a1a;
            outline: none;
            transition: border-color 0.15s;
        }
        .lock-input-wrap input:focus {
            border-color: #999;
        }
        .staticrypt-toggle-password-visibility {
            cursor: pointer;
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            opacity: 0.3;
        }
        .lock-button {
            width: 100%;
            font-family: 'Inter', sans-serif;
            font-size: 0.85rem;
            font-weight: 500;
            color: #1a1a1a;
            background: transparent;
            border: 1px solid #1a1a1a;
            border-radius: 24px;
            padding: 10px 0;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
        }
        .lock-button:hover {
            background: #1a1a1a;
            color: #fff;
        }
        .hidden { display: none !important; }
        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .staticrypt-spinner {
            width: 2rem;
            height: 2rem;
            border: 2px solid #e0e0e0;
            border-top-color: #999;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
        <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="lock-page hidden">
        <div class="lock-name">Xavier Rivera-Lanza</div>
        <div class="lock-card">
            <div class="lock-label">Password Required</div>
            <form id="staticrypt-form" action="#" method="post">
                <div class="lock-input-wrap">
                    <input id="staticrypt-password" type="password" name="password" placeholder="Enter password" autofocus>
                    <img class="staticrypt-toggle-password-visibility" alt="Show password" title="Show password"
                        src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==">
                </div>
                <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked>
                <input type="submit" class="lock-button" value="Unlock">
            </form>
        </div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "Wrong password.",
            templateToggleAltShow = "Show password",
            templateToggleAltHide = "Hide password",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"28104fc9b1b4ed40f6f359601972e88385bbb4f720f0c3e0f390a5f4d38a8141791a88017650e7b84a9975bc9a1e58bd85b090dc44bbaa368fb75d0d97e4f5f81672edbef668bdb19e5dd2536fd4e2286a9c9a6194a3076409c7ce538dc0d1c38e392273c793188e851dab0db90bea8a1734d1479ee2eef1a2ed286e6936c5e83fbc20e9646c5b2ba3a291e8f788f26d43b6b9162974614d1fb26965ed684922798b98d5f58d93160a681e7ca36830985c8e2475e1bf8bc27ec43cbba3fac1ea11964e041de3447755c3443457fbad7e7982914007735351dfb8d9bc1c270b8d7853e471c8a34e59c1ae831894ed680a81749faa728a6df9406ab8c7c1dd03b53d51c6e3bc0d668ced9992abf729715e71554436611a80e344fe373ee8f61028e6ac58a7a9b01f52fd1b1fcb1c609c9d4a32f9d537df1658e5eea8ea4cc40f7011b98ba000ecac6bdbcff904970b673b196f0a17ed61111a65b8e7ffe75143bad4b11917e02257bbd8da534865f8e98fa8c8af99e525ca42cd6976bdbd4d959f8bf4776aaed9aacd562845305dc4a8557bf402ef79ca6e73d0d479e08d1d49d5f164a2c399b433b213dc9fae0915a71550bc4e1ae14e849c97291ca1e2bac02be45e83011704f70fa6de43bc6182924d82916e40851519eec9a157568c84556d2183a981265051f84210776115219fd40df9e0f5a4a39cf02712b71fbd7fbd65e4fec6db3cc99372b90bb053879d435233b3bd1b15eccdebb86130307ae34edcd8b53834789da62de54abdbebd3e207d45ab130e99aa8178156590390d176807890c971409959a281966db94a77a866bddf882d74443d722d31ebe0e2fa72c66b7a2f81ba3d5945954a201aec00ffa954006a06f22004c726479f09f02c37d4300ee4b24257484d596e8e0163e4583457a7d3e07ef5623e84fc3018ee06bedefd0d5efd4adc44760a7862196c6e91090154a6171a49ece81eb451737b9c1d1ab09eadfe67245aa6fbf515c61ba2a6952e64465b5890bed38ca3ed1206f1160c4bf8b67f66f6c13f4cdc6016d2d58e87e477860ae7b463154f8ce9e2141282556091278a5f298c96f96f6f5a9fe279d4eed893937763cc76584f8d6c0742cb819df628fa2e3642b5c555d60db566ef657eca2e405041935f9f50196cbd64449e83e259a4ee11285fccefd31f2dc1217a0fd64e68379c4d247f0848d1a02a10ba8508b3fe52b83aa500ffc387a748de4aea673099c9e83a30fceed7b1519d90b78a032e38241c2277c60d8216f4025936da2a2e5a67f2b9425aac49099c0c656f0d6005ff335a66372523d663a6c6ea6caa7625759e6d07cc132876cedf1cccea53476ab768a977b07195adabf413a95b3e8bf793ca7440823fc73e758af8d78f9c85de8e1adc8ed308edc32f766ce616a7ce863a81b2d4e9370e0bfd33b649373c7bcbdf3e9aa4d24e9cc05e2662b2b312af6c6c4d426abce176b7ffc63a42a60d2975a0e99afd29c90b63eddb39c5bd2b75176a3e180c01c375663100111d27e4ec09c0bafa205468b169b13abd1f3acafc7280ff8bbf911cd8a154cd5853ca18302d81b2ec2260bcbf9e240b82ea2d26100f721f5ba88e9c67a593b86f40e70a3d547b47476f2ddce0247738890306f94f1210177356a03b301ee7f9d7e4cffb1b228f0d39d26a479ceaeecb0afdd88d01521b792378eae21ae622ca709941eb56b084ad8e78296f8457467d0b1af6a5ef6b3466d9e3fa9e884a37b9b0e981139fc7befa7afdcb94797eb6f18f7f1e3b0e6bef8897a6327c6fb08fe6e03dbb840f30bb3f561414ccf178474b3f69c7c111fed99d13209a7806ff7657e8bcdc13a82796ec88d31ba797ab94aa6a2433b53562358d60a9743e6bbf0e9f9e3f6893e58763a6bde8b6f692fdbc71745d3537ffaf781b64773b2c40fc467f6bf29701689dcf9b18dcd774dd106f81ae983b447f418b1c896ccb9fce24a71817a6c28faf64e59bda0c166904fa9627ec2d3d3bc3a08f2a20a3921a711ecf16aee8421174414440e05fc4e5ba1320c55280b904b731c3a7e6247df827f6e58b8a07333153b9bd71f999efc83882de8fbbaf4b1e08cf8f1f477915792d510993d1a9b0bf717b5691af4cb063293f3f3815f709d1b3a22c4880335d5cde0bee1ce5cde6b6508030abb45fdd461e0ecd383e2322b07f588623ed33f0f99b85139fd1d4bedd7eae8f0bda024a11021c2d5880d22230f16b8058266ddc121f550f4a5c2b974318436f826fe4cb7cae3231864fa1a9b41e1a1046aaf380ce1b2481e48c54500f926c9bfd9ef9e7ec8d6c7c17db1f54a7a13ad76ae249ef35727bc22af01a2acb3f854f5b54ec31121183cae53f8a806bf019baec31ad5a724858ae3c36fa397f402f13674b2dcbad335d751d285766b96812a33db0c742beccb1d37199ae496ebc826ca715da11dae06db050d5a1e58927e0d3d9f103a2517257deef3d90f8ea2ba760fd7c2a827645eca44f0832a19b49ee653d15ccb7270e4fcedd8016f1fe5d424ebffeebbc9bbc0ea45a2c3c3acc3831e03503bbe53b77b6e44cf71f02f25011774da38aef548621c9354dad0ba9708ef0ad039a875a914b222e4fb1fc5369dabdbc0c24a01e1da94cfadc945cf81df1aac5b3a7505a6b6277228e64c4d3ece68fadd5125c10f5a884f08d1068c2944a95ee6c4acddfca6b2d10f993f9f6dc89a58313afc6d208a4be491419aa9a457289fe0fd79530201c2ea7ab6afbb0349b1eb3940f36634020dc2cd6ad7aad5f4c8eed5ff2ec2fa81c93f51a4cb0e801778a1e0e99e7efbca72eb5e4ca8603cab63e1d9ef9f2c368098bb6ea2d7f34bf30a1d7b462ed688e9bc66bec49134fa8e972b151fc6e49900a4d8acf9802c4e5136973177a20ac285faa39f67f0ec4229a024fe87fe427dc0de17d6866ec754e58872248e4f4f5d6586503f6c4e28652ba50d8f7b1151a22995ccc46e280aaa8fb51bddadeddbaf41955c16f0c5769d11e35e2405e6d840c10351e9aef8d84c5f22ad133d63fd2300b56f5f87bfd13a1da74de77ffb682f30fac2ec420a0efd5e80c069b2d7bff7adefce1030cc322834e803a609c36859b128fe6e5aab63f7a868e6317c0d3dcb79a1199e120b25c1fa89c5381869c64dd66fb84c62bcf329f5305f04dd8511ed4032cf6362a8a9aed21a0f3cc83b52bf104c613b284f95b4435df47b75275d1c6bd016212b868f355cb71bb28df0b5b9a6a28cd5d50ad6e0bc199233ab1a297ce8d0fac44fa236d4f0c3b75c9b9b69a7fc62c7f3d68cd046b638d3328aeb2453c2bad6396322cf98b906f99bc5c075ded7f549ad41b1a348e9fcf1954c077adaba24e6563fb9c0f8df87643bfb43e8585795d1b9dddc519a544f5ca92586fd081084c19bbf37c1278f0ebb4ec3fc734abaae783265e68faf6139fa5488f96bf346baa5119ff88db8640269db9556db651ca4c722794e29824cf27d3f261c36e5c8ee8a8a5601da4e665efcfb16d7e362afc6736e989184b00ecd61ab254d1f8d460c235a2872c85a4385f75a49dd2d772e43ff32c9162fa381c50660b5368157cdcefca103988186c80b7ded8f2220b022abdc87f0bb5cdef4100c57b32094bc240658eb29f3c458aac3ce00dd746fea7e7360766ee4e5de816b05ecfb3740c3b699bd800b04c8078985161cf8d3ba0b8cfbaef28be8932f60f060093866552ffdf7d664c8b66809389a7bf89c898484ccf1fe97630fc51dcfed07a17e357c534e4bd6e56c341a8396755c3f7977fcb330f5f6f59369550b29b07e4931fcaf24ee2fc92e877d93e5314c2be7d7fc3a9b70a57c51cba607a21a4abb42898d65a8a6ea11f7d9b236122f17131e409c4313025f5ac04dd51ccf0ffcfe1e99dfc44b20ea6a9bc916594308a2badb797e6aff3244330ae11cefc349aaf52c0263d06cfb21ffece934763de71216b9f48b0dc1008dfc868b2cbf1a3c648fab2e765ca426e90098fd8271c96dfa4afbb5e5d063c4d9bb1d739c9e86475bdaad87b14a891951499df8434791b1893ca2d1fc0560c7dbb58ab73e3a8762c915d08d163c70ed2e1e990e800a007c2490e35b9d7bd26fa153654eedbdd691b0d10af543e747363f8246ae9c2e345b701521a40a6601d614a8edc50874ace72d9dc41a6d9cc61d952d6ff5af7498688d5edc9b341e86b10962e275c49f3f2dd24d9931d946f4d0394afa0ce64cf572800b5f197fb0b8b7b12890fc8fdd9835cd812b54c07f3a4908081ce914975ae76743f9c354bcd3b82963897310f647eece091ccf18251181d47037caac6165867244ef978f79bbd6fa09ee1485113e60359b30320592decaaff59579e829736296f9e80068102a9743bd3ca9b79e38dd77c953bf4623acbfcc83a86d17d1a14123db00e3ab30f8b738e01cfb46a45ca2965b734483796618a80808026274a4433acba48f22c7cb2aa8665736fa7e40873c39cbfc76dd7ba8c0a9f316c42980269f3c8fd3482dbeb26bc48c4f009c5a8243fbea1e94ca5737c8db9b745d726ff72ecc939f83dbd4a8fac824f75c167af12e2936b902ad0d68aab2e1d98bc5ee259156ae9d08e6d911521900083b2751c9106fdf0f6347b8e5c5ff708358703364e8e9b90079372a8706702d36ccd8e55fb7827e3469d21d8c34919b461a18888ded716c64ada4e221336bde4a58935035e3fec16574e0b1807cb06cfaaab6f1bdeb5ea6bf7823c375b277d54004da0b8c48190f56640810ece34cc1150b655d385c8b3d38581face5ad933800460e01e092c2b09de3a9a57cf1b6346d91880d43f0984bae998fba066d000f25dd65074f488bc7b66ea8da429197b2170190f76b3640c8a99b1ce28530f55845f35362fd6a61d3e94afff7bbb3e9e3c69db1a568a9da0113b56996907b6d90b9fa41c61c3112b01e88b02511f73fffed9da170632be1d4177fe48027ec04fad1257b29a40b264a6c90dd513e22669351982d20f70d995af112ff305e91567ca40f56eaeb8e4aeaaae3d75a20353f79aa3d46945f7c6b0d83ce02ab1c5a199e971d4b96b3dcdff1406e29107c1cb2394d04001a7978c859fc60bacbb3b81891a5d9edb4943345b7409722e58345e24182de56e0038b6829d2967f953755f2eaa89c905037bfc65bb2874104902a5a8fbb328aa76ea808522b0aa2c4a00e37bc5c1f6e867b1295928eec7486df909adfc74fd3a0cb2ec0b51641c463e6e101428d8a12d3ee7a4781477dde2bcaebb3a8fb5baae7523163bc7e3e94f3916c6e4103175134c37011926722d406c5297b581600eece686b3964d55b7afe28ea573eb53a5c585d547bb98720552845196b6528a70400771306a861177c9410fab7d078843ed86b2ae0c23ed339697a17b94706f0dc7b44a279b4ff9d2580d2d3922769ac74225ccfb004702a9a9ad6120787a3e1904f71d793e1d6088df51b6f283b88c6985adffbabf064699d5cb29e2efea69de2149ef76b7eb999aea997701d7d79f9c13be562b06da7a49209ce6db73a41851ca015a7075e6f0ef905ea2e3d09e0f80c6aea29120e462044378c57510591aa05ad9e2b0a45e835041a7f69a10d4f66803c34ca0a99a0ad53ec3a4303bce851210aa85daeffc567ddb1a0a09a82dd01bdacd2f2a901b3d5cb50ba56e71cacb2ac525c4f918838874998702efb80eaaed77b262c761cdf4c16b46425ad0b4a91377ee00424343bb3c602da5383eeb592dd86cb1273686c895cb5ed68fb01dc721df564cd6c2e8addd3aa863626d747071df68508347a2e6d7c5c9eea7dcbe5e0c11ff653aaeda35874f159c5a741e4fd0922362dfc46a8fa5b5bf1b1e7642a98c645b99803f7124948ff99d9485f02ebe8e02bab7ed8e80d73fd0c36921d75ecf8be29a8c210fe37b8c6509d2da6ba9b6e28dbf8889455235c702944b53a9b615acc384a2a90de216e2ef6416ffa12ba0e23067e13064d3e9c1102fb489c2a3cd171fe7bcf366fdf5d92d5c7a27237bcd8186155c102ca52f4ef37b514ef406b054f0d80fa5f91a697c51b5bd177ea8b4d3121030105b626306815050d43e7b011f470398de742612d8869c0f3147e01b0a9564069fb4372a9a45af0bd502ba4bcef54f224b81330efda20a3ce894a3da8ed5b6ba5f5b0a6a4f29f1f10fb56c4e5d5f2b4843d5f160e43a3c14240feafe05b675d04002ef83107e83233cc005220ae70ab8537da5962274a1246c32335eb647aba5ab33f18b1a8070d029149f0306d30342aca3ea225d27fd2d2b657e735463ef156e7f66a0ad8b877c9874bc11167b1b94db971331005188d7b90af7e7650c66eade52c9cd9df0bdaa1748a9eeac3b237d7cd6aa475d3997911996096a3dba05b67dfbb53d70dc28dd3519401f99489c7de47789023aafa5da6596da5ee492828ea3d18534a516b6f81c3500d21b254c1f82ced60e87ee0e5bff2ce3bcc12a2ad8cb072c5cc3c4e1e73532eec015b0034d71808e17c91e1632636bde7e872ce3b97324b1838e5d5a1b9c42d86f46dd956f68bab640101a3cd8b6f788eb16c7bec33e2ebaf4a4403158230182634c9b89c1552264129db16acffb526b9cd0df5a4ab3b9cc2c61a936a544f213640aa8109923fa4e7999639cb94091d036eb23e93a6f8d3adceb506b5071ac0fef6e77ea5b328dcf105909ee2f254eea30338b22727868014fccb2fcc37061884f4dff7bc645769a5ce3df65ee08cfba7555ce48c684620ed521a8df5329796bad2f8ec2a30fdcb0df7e1f13277a490e8f4654bf7bc5728885efd8829503dffa8a9c0e3f7c9d7bf369507695145fea99fb9a9d17beb0ed3063f977836806d38b8a32928243714f7db9fad42af07e5d3e90c8955d152dbec48b7c7caf0baf010295952da398fcdff4b5c4e3130115ecfecc308717d3a0e3c93afe27e9e16eaff2153aca162e1ec3c4fb24a033b23cc6d2cfb42ab550987b9f0a99a38c3dac0f9f31d9e0ef338e16de028ac15baea0ce7420f4d1873296bdf3b6f68cf5219a7b459bb02360e626fe6f7915932bc4ab7ba1695352ac2b0e1a14a2e5afb8f65971742da0945b45e4a28687980c80cad901dde449459da9c68d1d3147e00f959d007595cb5f005f23bb5d25b5d9ea77ddd7c1d32cba0a3d51b7e6373ecdeb150642a6ad42e0291f2c12a7e7339a6e89fb4f02eb25c02661ab370ad0f51d429e50ea7822e31a5fde5cf5790ccaf6efb6a1bace0cbe434e0da29c831f2208b918663af707500b1c760a5f7cda25ec0e6c5465318856af16ce11d2969ed498c2f80d9c1b05066ded0e97c10b44a43641fa6496010fccb85e0cab39e0ed998b5a4ed735d78a8746fb036795a04ae7a958074d8136debff5735d56b90edbd6f491c117540955fc093d8e98da9eda04bf1f4720a5ca1e6b8286122710a949c1853d62b041881f4abb645de2eddf2315f06525b64bb5f45e92ff745c4cd09173f538cc7048196b429aa1aacab0e6758fdc51836ad8be4c48d43c216e202f4453bc0ec88a53c2d7182fe1b422ad99cea73a417f9623a635b9c4de912a225d3fef65fb9639b80ce18075c57946eb2179defeea8aa2c93dfe92420c2020aaf0ed88cc0bde95cf59e8f92936caf58c7af1d32163757dbe1e64b1c5aa176fac77be7ee3e91c8b58ea621f4353ea706cddd68b3b79a08885699e515819696e239b8c9b1ec5ae662a60f085da426494a349a0ba94cbd4420f5d22fcfca2e9b2c8794468fd19a785942b18a10693f53c480dd04dc360d162102e0c5e4f1825100b9d361704870f73883747d33f61750322bbf359810fa279b1070dd6f86f68b2e37d382f89d1f3327e714e2e0be3c883d7f1922b49d59aa33547ba698ef1e40b1c2660c0b5e45458099929c94e1efb13c2af43a5c1dd227786b8e5b59b8a62829c14bf8991b7fde41e16d589f88cf6440a02ec38dd320613316ad4ccc7a19e896c50d11758c4e479d4de63f5cd9bf3b89a940e292b6f8790a160ad2dd1ac1d35240ea2d3985c98b31f89a44d0c6188f36030fa8400f1924ddd69f174db3ce95ba077888bdc823b8633453ff4e26a0b878dff38e4d7c0c71149dd354fe6e042aca484b76dfbe47e9ef7454b56ab85b8c31ca9ed5a4ff88caf7c97a19b73ef469b5f9c514835f8d34e1f64be57b2c56518b1dad81ffbd139b90c5dde317646ba892efae7e5aeb35c0efb416193e86ad5faeb10adb238a31df3e846aa76e11aa9b0747f582d5a8fbc4b6200e18ea44c7aa84c10d1d9b414500945bf3a0d1f91b93ccf4e766c4d5efb0a93ba15aaf95664d8427e59ff0aa39d9bc805531d5ef5ae3f29025461f8e8c71bad9bae16d5da856b870dd929b75bc41fe4a100975eb0527c697259f1d708c92a80cc132d05b035d450f5a68bb83f674237a28edbfbc13ea0f2e1fddb0e5e5a4a81f58bfd63bd225ce657b6e287a1bb2283155d98c1bd781964c7eb91fcb8bd838b76aeb07252de989e41df29a02110b0d6228e28458b6ebd14e496b8971fc002f23b2364cfa4722bcaf4c9775db314a95f120a6a554e906d2062ca6f0827bca59f13a7d5564f6ab82a9a3870f270de82137915304cfc08c2c68997259c9fc159712ee4c31be20b94b67c8f1c9d655fb66021ec3874cc038d14483fc2f3cf9fa367209699d5e0439a94deb7c4f15fdf0d7f29415","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"3ce507516cc56ec0fa738732f387e94b"};

        // Use default document.write (no blob URL) â€” keeps real URL so links work,
        // and lets Staticrypt's built-in localStorage code run after replacement.
        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
            }
        };

        const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
        const imgSrcEyeClosed = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
        const imgSrcEyeOpened = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS4zIDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
        toggleIcon.addEventListener("click", function () {
            const passwordInput = document.getElementById("staticrypt-password");
            if (passwordInput.type === "password") {
                passwordInput.type = "text";
                toggleIcon.src = imgSrcEyeOpened;
                toggleIcon.alt = templateToggleAltHide;
                toggleIcon.title = templateToggleAltHide;
            } else {
                passwordInput.type = "password";
                toggleIcon.src = imgSrcEyeClosed;
                toggleIcon.alt = templateToggleAltShow;
                toggleIcon.title = templateToggleAltShow;
            }
        });

        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, true);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
