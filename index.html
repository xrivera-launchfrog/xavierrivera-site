<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow, noarchive, nosnippet">
    <meta http-equiv="cache-control" content="no-cache">
    <meta http-equiv="pragma" content="no-cache">
    <title>Xavier Rivera-Lanza</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; }
        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: #f0f0f0;
            color: #1a1a1a;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .lock-page {
            text-align: center;
            width: 340px;
        }
        .lock-name {
            font-size: 1.1rem;
            font-weight: 600;
            letter-spacing: -0.01em;
            margin-bottom: 48px;
        }
        .lock-card {
            background: #fff;
            border: 1px solid #e5e5e5;
            border-radius: 12px;
            padding: 40px 32px;
        }
        .lock-label {
            font-size: 0.7rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #999;
            margin-bottom: 20px;
        }
        .lock-input-wrap {
            position: relative;
            margin-bottom: 16px;
        }
        .lock-input-wrap input[type="password"],
        .lock-input-wrap input[type="text"] {
            width: 100%;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            padding: 12px 40px 12px 16px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #f8f8f8;
            color: #1a1a1a;
            outline: none;
            transition: border-color 0.15s;
        }
        .lock-input-wrap input:focus {
            border-color: #999;
        }
        .staticrypt-toggle-password-visibility {
            cursor: pointer;
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            opacity: 0.3;
        }
        .lock-button {
            width: 100%;
            font-family: 'Inter', sans-serif;
            font-size: 0.85rem;
            font-weight: 500;
            color: #1a1a1a;
            background: transparent;
            border: 1px solid #1a1a1a;
            border-radius: 24px;
            padding: 10px 0;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
        }
        .lock-button:hover {
            background: #1a1a1a;
            color: #fff;
        }
        .hidden { display: none !important; }
        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .staticrypt-spinner {
            width: 2rem;
            height: 2rem;
            border: 2px solid #e0e0e0;
            border-top-color: #999;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
        <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="lock-page hidden">
        <div class="lock-name">Xavier Rivera-Lanza</div>
        <div class="lock-card">
            <div class="lock-label">Password Required</div>
            <form id="staticrypt-form" action="#" method="post">
                <div class="lock-input-wrap">
                    <input id="staticrypt-password" type="password" name="password" placeholder="Enter password" autofocus>
                    <img class="staticrypt-toggle-password-visibility" alt="Show password" title="Show password"
                        src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==">
                </div>
                <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked>
                <input type="submit" class="lock-button" value="Unlock">
            </form>
        </div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "Wrong password.",
            templateToggleAltShow = "Show password",
            templateToggleAltHide = "Hide password",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"46bb71d5fd3a034bbb1873180ec8defed7a45ea0c92189a6a6aadde5f5f4e8b44085e026ee507d342be533b80305b58f4a2aecdc13ea57539e6a2d7f51fcb757ad4be16c46d0e11375df5833fad7e4c5940cbcb4f3c8ad626ec277242ea002a8ea86275ea956fd06a9b5698b282917ca9d5cf25a721be668f6914c84dcb49e7efb0570bbe4bb05321db92625affaf668fbf1a845bdc3ff455053378657221de24de4232205ba04408762f6205e0dea186f11082cc4ba352650d325fe5aa9441e1cf2fa3f35bcf1b84c60e6dad7c17be44f5145d5802c4bbaebd399f64a01f29d59589f54ee7447aa8f40817c31f1d75c9656b8d919f3b592eaff9cde1b90fde6eb82417c83efd190854617c609592dd7bb94930a00b2ef1f0eb583724ecd50fa02fa2e51b298c6cbdd8abef9fc2e9536efb858849326647ddb121d5420d15b0d1c92faad5bf054a978c973c47f9708197092f28427c4dade129030f3df1ff3574576c0e4f085d9373b38b1889d6db55821e4e8521a11956a6d2512eb2977337b7531ac81825987fb9e8601aa190b597a496709fcb0a164a4b9c4ddf01be96837dcf4971dc77fca0c0b27f92fc490d9f6293a7bc7e6d5b2180ce105a4e9e4f2d7bfeb5af32f23a8640cd9ad3ae0b0ac00bb5c7ff7cbb2e588a5ca0512db3366b41e8a1b184e25b35f8f8ec1e2f62a487043355871fd7dd37ab3da8f6ff94999602dac4ac14fbdaefbaca80f857ff3326a5315072e37c1e3a400e2a5a6898a236776dccda773795099827c12eb03d84aff30d3c6f2c4577a66e9710d65fe01767eed2c62861570ee17e7a2b43e5cf2862b8560050e86263f757376563468d5c5454e27b561663ae6bd9d494a12d306326890b89bdb24f00793517f68cb398983a494d845ef7ec1e71cc59bdf0c5e00ab0f1fcbdb2718f86c80643f045ec61cc57de3877e0ba2cde2d618263111590b5298531ff8c4e2487c8b741f45c7256275620f3a78ac799f08036987dbf5e6dfef2172fff94d02f0bb00f18004c46a58ab7cb3bd9e1c5cc0a27e73ad45f60bc716c05cf6045ebafdb13ab247040f2eab3cf0b2972f34e99154b2a9b4e0382167873e4a0402dca6e70850a9d56034cbac4d177f7a6fba1c66b47ad37d217c8c3aa37dac5071761329839f9ffc735b56869acc926ce1cebf6eb3d8d9e039c035c0e08d43993741fccf5fc077639a0a2f3c39e58802e0b692250fe9abd9bcba7d23b00367786e256a5a72163574e06d4b203788793cef03314c6ca6f662784f8f1afeca5b8ff411e8cc52ff2ab7967074d030e542d9981893fefea13e4351f2ec2a293dc2d4deacf4363969b770405698b05431117c09079c7ab22ee3a0421b3cc84f92c49b41041a48ff3c0e96d8e3cdcf958b9f110739e38c5dbf0809802199677d95870d0a7559d9552f35c5e970a419022088fa569dc1dd34b40f90d737b459d5bf60a2ce975bdf6e2487ddcf0a0d09764ae037fd615875f12c5e32dfd51eccedbe01b20ca8f41ec137f2764322402cd83ab3def65c41911367920b3d2e4465bf58538c7a5372842428082cce7fbe45f1b8bd72c3105765106e7b178741d38ca73df61a0d5fb72c01da3d8f18347513459e255bb67d790a9684e112e5f33fcd43474919ea6cf8d90e3bd8f0af68590d3f992734843af15e80f001e8729bf9ebfce0e999a3ef6b12ae06bda251da8dc71a3e3fa8b3f8d77202d596a34639c991e2f7ea1099360848e9ff0f05869cf3913db8c073b4d85cd0a54f3f9fdb0cec5baa35d09b7e7c5b4b4fec279d88c15a8039b7ce6a804937454b92068007f2ff4edb192599a35516b9ac55fd64523d9f9d79bee25b51950139947889b2d1d29628e6aca7934b9e68e419ed6b4bbdcc2e0e76034850c2a408cafa9df6c35229f4be6bfcace709031c81631543ccffc3eaba011da0c853fb427427377ad0ea99c42ef812f251e9b5d2ad6ffef9029176421787d63b26766552a1cfc3ffb2eb6a56a12e810371b5ec960885a246a30e038c8991c6ada1ae7218dce868308af1f926f7f3a83ffecba435e00ec034060369471c9e3db68069d618f5d3e7010e3f66f69f5680213ccb18f404f6ca5764c824bfda9b545a5a3bcd32ec0818ccd96609dfbb5a9b4d93ae2fb3bd2c8b8a9642ed532858ad085708bc161ba9d540781d6a13fe372975cc309b0142921e9566c0ce34aaa0e9bdbf7ccb567ce17e7a240a2c55ccde32fb48f8b8aa4bdb8d4fae6aa4bc02e6f2655a7a0310b99feb8162bbf684669586fdacf05866b1fb354cc071f729bd14622e225c9e3df57adceab8a782d219a6e181d819ece189144f7f00c62c4815c5748fdcbeafff5fffc65ef90bdd8ac4f66c8c2a8dad4ed5cae7b2b54feacb22ce77a0a67bc265a7731b272e76c4bd6d06f3308663782a654efec71a9ab749194e42b48011e5efdaaf1673fbe3221af806b15e182ccc90e48eb7a5b1ea08f40a31c3af68e5d5fcddb25c3ae416d6ecbd8b3aba4f7b7c150634bb72f88ad8712d5d05d499eee8e2398218db6d1fe0602dcf8224cce44ebe60604fc8e81ea6812a07b8edda59c2d89f075977aef46c271d09568b00851f8298510632ac695178e7d5eadff6e956a0b8730278964c5e8100cd4ab1497a08eb9d1f011d45e4f515a5f344e5a03ba5d1a6bdaaa0de607b43275a81de3b53cb936dcb413eca3b5874d8c1888de8283da4000c2cea6f29fc7b2f90bd001d9d5458a927b99fcca678491815d049739b403990cbfebc02d016975fbb61570a80e6666ef82333b2038c53f4d9bfbeb41e85431d22833c6250d515dcab3f3ac3f727fdf0d18dd8477f5c52a30f4a984c75bd1f7cf448a90666796135e647f49326102e761ba4bb121ee76e9a36c42eed56e50655ccae82026f073070e581051d7113d0044c4a8b8366b38375a389b3e449644f606b3ed2e1940b3f917e64b41c2e9586ab18cddee7603d687f12a9f2decfaea1a0101ac1ab5a27138e42f42e4a782d35c32bcc139be878a01201cc3ac7fcda3f51aff3ab85df4b62a0cb97e3d926a2d189498dc5ed86e2e8a3cfbc5fcacb85a114763f386e56e1e7955685b492ffe862cdecebddde5618e66a4b12f93c17d37a81e84bf4d1471f78be6c2b397397213929ea92d24d57ecb3d1eadd8d324f95c8dee3b5fa96989b3cbe82d81f7b89abb5b92d7788123041fe040270c1b8f383fe7f949921b75795055cdfbb2d0817ab73b200a6c19545308e197d708dc9476e600ad60e61942a0ee45b2cb215e874c630698792f72dec69ade6baf7cae3efd34f8d2f5d4aac8424a14f9232c6e926ac3a606a3f33234627bacb992a10bafdc99f6296d2a3d68b1b93fcee8e6d90bf32f2ed1334767e1e692bd8b0d1cf1d74cce4b89f23623918d2f71798b82644074528d31f71a3d1b1ff6a9e8bbaf98675b24e0631a47f05b1f160fe91e2690b076328bb239949293bd1f4d0810400bd545739d8eaf0985d454dee9f885ce28083220e2b22dd8b104a09c1b31e3b9346d0a3d98e89423badbddfa951ae983c97af52bbf318a04ec6531d630b688a7e0540837e57db33535e337841b43c785145e9386e19782225c569d2afe6b915fb67973f10352f641633abb1ed5a11a39d6b9dd177664bd9f7794789476ff781634eb1dc8a91ac0dea9d203738b518a7082785640444a3dd3b4c5cbdc59943d4d3345ea4d680f0c8f351b8774c13dc047f9e927687fae0b4861258a03f12d35b047a8557a77532d30a538752327887e02a26e913782f4ae962d7e0d19204bc25d18b50fde37d8bde66d258484363b8c090188e8afd600f1c7dbe5d47db89254e0818f568fbaceaf49d143917731251e0684ba4acdbf2028afbfb0c4b4ef697032e7986a716a5e976012f69f3f55e5415fa56d490bd4325d159ee279a0ffae1f0257f992277db179febf3658b6a30f4add51174e50f9a1390551c8c201acbe66b292d76998cd35e3b5fd61b721a8acbae06aaf9aa9a1de5ef38fbcd9269563acdb21f651cbc1bf774c1c608dab7eb7ce787bcabc30259ef621f4a73d53c0bb1359d6ede208ea46ad6bfeea3f143f3cf2dbef4f4142f19a89376603c211cce2fc85b99c6e16cedc458a3b1292569115a5e6b4ed937be52c3630fc0f93540d3fd4b96e5ce2cfda7cc1beff93050a7cd8ef1838e6fa55ad01c8c3eeeb77c3839ecbf63ff961019061fbec14b627f337b35081ab2e3f15baa3690ab6f1bfcc6af150c5c4d78cb1798a709deed6de32d7b7dee572629600234dede3fa69c81c91d13aaab5462839da1dfe6e0adfc8f161355ab8dc7aeab5c154d0d6c102a9f1ad58a1bfcb6a8adc0d8808d3b85c92e7f04c68b3247a7158a5ddf23bcf5b89e6ea35f9cb2327700a0f0dcea6f932c4a2056138217a8efd1cd2cbcf1248257b9abf3716396351323853b18254d6554a30fcd0db1fc445b9ee3622c79309b626788f5deb73a287abdc7f31750e52d66a2c30b3eabdb36de100ff32fcdfd82a7eaefa1cacedc18b22fdedd3da2e38ef3ab15ba5e523f47df42f619f0167ebefa1696d219c5264e77b084d2b16616eb25bcd947438e9de73a95475d3b1825afded6adc2e63cbd7299caddf9ebcefaa0566777f8803c7b39064b18af92851ffd5ecf462dd6bc0e43e6ba55d2ae224657207dd42dd6020287ffdcee6c7eb2ec812768ab69f86d96c0f600553c2b083e00d31503e74bd69d3f607dd8e873d65ffcfdfc1bc0739bd22ad09527097d8b094d8fa9bea79f0414cacae94f9aa2d80fdce89b4880cf304f834bd0c81a84429a8ac0a0763d904f1995ddf69cc568265e3a02ba19813bc5ed623d1f34778dca22b40329bd84f1befb2f7e0154e28b6504e4d6fc28cb218b8cf3f05966499c3c7eab0c653baeafe5c84aca6847929d2d5f1e6bcbff5e84d4aa6a35d2b15b3e1c6c778699ccd651d6ddd266ba06dd3eed270767b59f3b0191c998a02a3d342afbc7d9860aa1772671b2789cb8cf31b58ee131c9ee045f0cb10827a051848279aa95f217d0d96beecb4939de6419f632e2223561d8ad18d0aad07728f99ea553bc31b63439e687114df938fc67e33ba6295ab5639881bbe756664d2216ee74f6e683ad581b5a862919513443c4fe6152f94ee796c9c2cdcbba33d11930ec642a0dea5d24d5fdb2b3edfab5a3c7f0a0dffd9470f1ae5c7b03dbe942ce626a940b5691fa3ed2f60cead9161466eaf3c4d3d39d43a7c687c8de03a44016165c1cd8fba51908cead2a952bcbe243180bdefe875d499fc80c7821b18403ba2d800307635a962ae174d26a8c8944c21b1c80537ada95ce017c0c1138752b184adb00ee19aa2401061f1483ddc82160e2cb73df0a91eafcc35c7314c5753f3ecf8d9fe523e7a574d5458f715c0b4272f9c9de682c84bf090f46940ef365b8122e7bdf615e0c711d46e7709fcb7bf9830197b5549a4e95517f0f119b5986b78e71314488e92bc8fe1ab693439884369596c96bd11fadc6385ba74dba348017dfec3b8f4bebc72e2e6e85fa4f1e32961c842c8ecfdb64ca143a15ffca2d7efa848d5b0108dfea82f881f5d5236ab41c360437004d33bb6dd09b10db17e965d36c5e42f6e92f776924ee555fb9224e6cf36ebe4d8aa03b933be9c614c6d26bc202cbb8ac1e31c16716a35aac644f6ccafb92f18ec393b2abe380f38499fe0e578e8c120804cc1f9032553609151e761d80a1e0fca856a4060ec899f123c6e0495f89207a88e77e9d38fac45a1bdfa043ab47b6fd4b9e836692997330a3840532d490a35871e7133c808fbcf6da0c2c29e0647c9106d7137557c79c077a63c85b391567b8341d3ce72a760aa075640f70b28538b050cb1aa3b39634e543c67f48807f8263189c664cb172f99dbda9cc7a3068ff90ac9685e175318760f0ea378ea7d44b09bf7b1c2103f1d8583f425d737493da7e1ae3c3974d981c7b844ba6ef5b4022fb438e4eadf086632f7fedf82d109c1ec4210c71620af1e10551846797a17fc579978e8dd93cd98129250b143d7b10329b94cba414fd3f8debeca6587b4a7ae04ae7d45e926cb840c3b222fc4a50f2a6d35a2c8c756acdd42fef8968a3e054d513980e8fc90b6ac43f124707db59f07c0e0f5c96c697bebb265b3c10e5d9d4ce97c36410df006dfc0536b58663530b8183dfc75c0ae3bd7a20757a4b2defb8cd99b91df69abd27b9705d475ed36f5678edc8f409cf404c0507c9cac5e292d9cbe4d1bf0a928e35b6ec0905568515a12732d39c82976a6f11548f6a5d6bc746a3b242a74f4c6511b5f0a1b1e21d31559e8a7ce80a6c5092c09276d42c02895660b14dc2c0501824e5e30518b1b3bb7f4fc8c41b83009d20ec2dc2f21456c93151e781d79774caa25fdd718d44ab04c03d33f8a25253981fd1d40069bed7f5bee0bb530e6c876a384a9b1011ad3911debe4fbeddbd0504f25f135c74fd3526e96f998799f0f00cc4ed3277247cb99ffa5c1efa444ca042f0cfa6fbdf82cec03bb40f0e14a678585b5f666e6e2717b36ac8df6e73e687196cac1ce646c7267fb00167f29448c35e8a885f648664a3cc2659288f668ca8506c4b63e99a6f63209a6eb7a8758bc2046dae5f53b4d84588ad3cab2b84faec690a1f77c51dde427e90beaf75d38f6a35ec0ba5f340ef2fe2a48885c950e80695a1951cd735803dab8b7eedd5e2daabb9705f7597f837bbd3dbe649637e72a4cb178f78a25e1dae480678c1b95981ebb0a14c0f781b664018e83a00b2408e04b659de66b09492ee9bab7d310e157cb52d817b9f6cdb6d8d5cd5c78472e3ee3660184eae00ec8368491abaa552ffdceea794be85990243acfdd59e50fb44783b01e17f93594bf63d4e39e947d04a0d35796605480dc39b7536a8088dd310746547e8e0baa67b5b1318409497e3b2c43be746c8182c866685873d2c111bfba6f9a6f75e829159faed45c8d63d3ccaff71cc71b222fc65c7ae5c0c9abef1e4f59d487de0e7984e9db4389c0744214160388c38f0fce03f1821c7e64ac40fac4200699593b3a758224e2b693fb52ce474a75bec99f51595db5b53a54099007f64a1562e39b7918b9653af605e1c6230d6863f8571c21032bcbcc03e99c82cab584a86563a25fc4489b8c586bd80cfd16e731fc2136a8bf1d5542acb6baeb6f64f2b7f33b3728aafadeaf45ad848581b2bef3164eeb5781d01698976b1f39325e0096085bd17960e13a322f4af8640d63b4da44caf7a9790a08db155cc7e1a4c116bb5bf0a864f32f92a3c770dabd2e9f718a2dba9cfd199ac417746d03f03536dc582fd2a6fe8b9dc3bb503561405d09705ca6475fc52ea007df80b084124a59428c15bc66cec5f8e3ddc03c79d55a32b369fb181cf187d48ee12ebddc8b80c44fce7fb922f1b4c53c80879570e321e4a7e2d91b5b372abef61539565b9f23fca213e455a039895d40511db4071a6da556bb43ae50daf749372618275421f004ae6c19c9a55f6799a293770205525f99d710b69d8cc72e32d4d8709f13421e6b54cdfe4846650b25c5a8f8f51f48d0e8a5fb68f7345787e13fe1edd55f8cb358531f568624005b21a5f6b516f0009951171da7c1eb6317c89ebadd73333031f13cdd08458f39f65bee026b97becfaa032582395c634d84570c6bc05afa48f521e37bb8aae2a29d527c08c4879578134919ff751cc8b8ea2d57a680fe7f72e6da0928fd1d0f155178f00b4b5f03165243ae8218dad60dc53993b6389e8ee4adeb674f12c2c66dc3defcae156a7a0c976411ddea51bde08bc5ec776ca0e6a2e9045710de57163e7250380c3634812b23440fcafde3171c9662482fa14f56081c5ea7cf0dd34b0ee8b1ab2a897cf57d88836a6b7118c7944aa97a59b39e564ac0cb53fb98674853bb21f82d96a981444d60bc933c549cffeeb016df0f6415828e8a2f878c74566d37aa39a96f98c7a94dd2d95d209b48b48eea83c1c6318af7c3589056d8cd417ebb16097640c3955bdfc39e42bf5e0d7eb40c60f1ad1327b695aeae54c521f4f87fe9b8312fb04b6374dd7594dce41ac4958675b969c4e8823ce3633741cbfdd3c1f84ce811ec2c29e1af38577725b16a4a82fc48983b5d062d3c618ac4156f99abd7c7f1a550809b54f7aeb7d684a8ce88f067d8a3f9431f758eb13c3bfeeca1aa2488be537f2507cef769fd8688ac5bf74bddbbb2d40a79bdb3dfa16465f117b5fab5f8e50286d1edbfd82f27f02275bd5015715252b50a6bdb658a3a4cca1e43382491ecc3d2f5c55d50f80e7f83535996cc7dfa020e25c03d97c85ec938388e0758b8e28f5ae82fdaec42a8fd83e4a2c0866f98a4563998b6c29bf00e890c918301e91c2bedb416594e64cf6d1cd057f5f9de9d40505db3099a53fae42922fcbeca61ba1220355c7d781dc524e6c1b4d55692c1e0310e8888537f7aad4d0b43c71663c3c8ea0503c8b030965b2e6680b2df0fa4ccf847e3635256b7ce60afd4feec1a6b8b9ac9d1aae78efcac320f57749d9a0b9f0bf71c2857aff25dae0be44dc587333f57a44e6dca466fcfd680dde32d80a3b8093a6daac2d71f50a786c09600e10bd8ddbee9747cb91763df986de724e1575aa39853667553bf93cc8cc0d9e2d2b203eb2078ca4d8cb3f2c3af0a7c930c512bffd4024291088b831a1af9e","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"165d2e0d75d629e847a2e01a2ba33740"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: function(p){var o=window.location.protocol+'//'+window.location.host;p=p.replace(/<head>/i,'<head><base href="'+o+'/">');var b=new Blob([p],{type:'text/html'});window.location.replace(URL.createObjectURL(b));},
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
            }
        };

        const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
        const imgSrcEyeClosed = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
        const imgSrcEyeOpened = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS4zIDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
        toggleIcon.addEventListener("click", function () {
            const passwordInput = document.getElementById("staticrypt-password");
            if (passwordInput.type === "password") {
                passwordInput.type = "text";
                toggleIcon.src = imgSrcEyeOpened;
                toggleIcon.alt = templateToggleAltHide;
                toggleIcon.title = templateToggleAltHide;
            } else {
                passwordInput.type = "password";
                toggleIcon.src = imgSrcEyeClosed;
                toggleIcon.alt = templateToggleAltShow;
                toggleIcon.title = templateToggleAltShow;
            }
        });

        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, true);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
