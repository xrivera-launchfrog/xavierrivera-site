<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow, noarchive, nosnippet">
    <meta http-equiv="cache-control" content="no-cache">
    <meta http-equiv="pragma" content="no-cache">
    <title>Xavier Rivera-Lanza</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; }
        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: #f0f0f0;
            color: #1a1a1a;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .lock-page {
            text-align: center;
            width: 340px;
        }
        .lock-name {
            font-size: 1.1rem;
            font-weight: 600;
            letter-spacing: -0.01em;
            margin-bottom: 48px;
        }
        .lock-card {
            background: #fff;
            border: 1px solid #e5e5e5;
            border-radius: 12px;
            padding: 40px 32px;
        }
        .lock-label {
            font-size: 0.7rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #999;
            margin-bottom: 20px;
        }
        .lock-input-wrap {
            position: relative;
            margin-bottom: 16px;
        }
        .lock-input-wrap input[type="password"],
        .lock-input-wrap input[type="text"] {
            width: 100%;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            padding: 12px 40px 12px 16px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #f8f8f8;
            color: #1a1a1a;
            outline: none;
            transition: border-color 0.15s;
        }
        .lock-input-wrap input:focus {
            border-color: #999;
        }
        .staticrypt-toggle-password-visibility {
            cursor: pointer;
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            opacity: 0.3;
        }
        .lock-button {
            width: 100%;
            font-family: 'Inter', sans-serif;
            font-size: 0.85rem;
            font-weight: 500;
            color: #1a1a1a;
            background: transparent;
            border: 1px solid #1a1a1a;
            border-radius: 24px;
            padding: 10px 0;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
        }
        .lock-button:hover {
            background: #1a1a1a;
            color: #fff;
        }
        .hidden { display: none !important; }
        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .staticrypt-spinner {
            width: 2rem;
            height: 2rem;
            border: 2px solid #e0e0e0;
            border-top-color: #999;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
        <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="lock-page hidden">
        <div class="lock-name">Xavier Rivera-Lanza</div>
        <div class="lock-card">
            <div class="lock-label">Password Required</div>
            <form id="staticrypt-form" action="#" method="post">
                <div class="lock-input-wrap">
                    <input id="staticrypt-password" type="password" name="password" placeholder="Enter password" autofocus>
                    <img class="staticrypt-toggle-password-visibility" alt="Show password" title="Show password"
                        src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==">
                </div>
                <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked>
                <input type="submit" class="lock-button" value="Unlock">
            </form>
        </div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "Wrong password.",
            templateToggleAltShow = "Show password",
            templateToggleAltHide = "Hide password",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"57f9c9281492975b558774f3cb9456a2f47e5da1391ab916f56ca0baaabda5efecee4c88789e0bf6158f8fafa1347d71ee23a393dd78cb3409f9dfa0e40f87ca01eb0fef5183b1ed5b4adf3fae3da23b0604d693db52334ed90013203688d1598be2d38366008dc572fbe3a0b6c5a076e616e98e662838ed8696ebb7fc8710315ca30693755904197a950bc82ecdc8587ddd1bcc79ef8ae9addfdc3ba79d2c5fd643adf8aa6270547e1add8c1d4ca43e43104ce2db8013dbd9c747584fd119b43381b81eca2e724ead506faba5ad02429c81369d661c178bc7af04e1055afb91952fd437590c277de8cf8400a076e1ad1de4e3a9b780a88bb5c9d78e6bdd03835a228b0bd820c50281a123f0593e30b38852c20b62768bfb17b6c5ee9dab30ac9996c0eea4c11d53c5191df2c69bce2c62df1ab0088c6a2c9a4f39fcb8e2d119d58cdfd9bb5cb1c8a3ace94bd8a600d6055d544a6bea21f159496055e21239dedc682232b3c6aeed44814990219d66d1e975a3f5d37accc6cbadbfcbdaa16a64b952eb39b4adb0f6a792ccd0f2fc49a1668c8e44b299d1e209a2a39ce45c66b7b1d55ff23f822ef580758748fed0c234298f12ce0061a19769c20c3fb2a577c0bdc064f6c35e768b3631ca597835a07d2bbe94fc5c10987ef964f2b041602c116475fce4d82ab795a510d494fd994e8ca3910d6ffa9ccf672443a4de4820cfb10bd4a5e5acffa9bd2bcafc3453f334ad7b546c169b2e02542c02e56ebfa428cba53df1f75e5d90cf3bb9a6c32d9cd6fa2271e0360fb87139c38a1df80deff13c9c4a2e0cdfc38bc9cbfb2177ebaf144dda628b03db7843bf26202627df28ea3e185dc605ed4ebdd91ff8ced1f222130bb3f00621b47ad843f3ed8b9a73118286570578c1484e634a48011406ecfb4cb3b13dc496d271e64eaf28bd34a316e640c6c76ff6350a3f69f79dfe0191d22ea2e5319ed7337b0460a35c9058e4999b3df85b095d169bccd261c1224d1a51a2c00b6a923457e8e3925c4e29529911e848e2747e2bafe1921e33b8306278893c2d9242cb1c32cc0bf8f14773a1d248f4e9b6cd7b7e9459aeaa4c3f77c251a7f9cfe26b0a99f1d4d0f11b37cf72f901d08e826730c196e467e209cb65da998bbae2af2dfb1221bfcc56480865420d239e97efa9d1c81786d46a7ab2fc43ee66aab9c0ad376538504da7252456d6e947088ba431fe7c85b53d2e6de837292661dc5bd13e6d1198af5ce8df0624448c4d124d17e430e135a356802f9a1f0b6bfad697fe73cf75df6601cd1a9f053c3467f226974f48a26461d35a58d20eeacaf29524209484a7cdc3bcba19a7e590637574a316f926d248f18c853fe8ea1b6840d31ae6d67b033e3e38bd4fa270804a5083a9d3b155af83bfd58fec220afe02339b02a91d3faa42127583f191bfb7e1db7605962398599af149aaf457e0bae3bcf1d6e72af90d8aefc0029cdf0c16eabbb0e46c825fa9e3f71e27a132176499a8559841e744228d48773b927e3a4e075b0746564935af20b68016711acc6c3397e6ccd685ee0ff09ca42e24090fd22a3153df542cc8413ab7ce19f005b587f85ce1238096d2288a4f248e9fdf8ca34afb2d1de33ecfa6cedb4d6f857627b707e4390a50566becf760696e0d2e3a066a561814ba1f26ce0bca2063adbd11e0971592e521cfe45adb4bcd0d00bb905d00919b17acd62b0728ee633fd28b79cafad0ab1904fa0e69948f791759c6247ec4e656bd14d18b1012982ed37cef38dd93e76cb0de1d2249d3c244bdfece2018dee3496664d5fffd1e6fca4bb40fb7da76468eb750f5fc9829862fa0000ef405300b9d82d010c3694a1ab62551189c02cc23413773cef43239452846e94e532d1306818fb4dd999f8da141af1107723e2d1db63d906b37164bebf43f2f1768e7b4d7a6d47fafae4b065905b49442d1875dd74f99961ad6d0a513d028ec008803a969cdc3576b44e67aa28b5a7eecccc46866735ab253c98ddac0a608fd57c291a398e2b09f0c1d8b82745012f13fa0994cbfeb701084dd5817635173388f4c4c71b8ecfb9a060336854700716a6ab2f88a89d2f4e51829748ba2b783da13ddde81ceea6bdeac7ff7d639a65e097c15a50c39d3c4e440f800f11a6766b9ca47d60bd53dfcf8b9d8ecb5bb6a7deea309e63d81b2acf8f7019291aa37b40d1873f67801bba10e221f70ea61653ae06154a3bdb149a09a919be46deb98d16217cbf1b16346ff4cf5907666802dd6560ddc273521e705b0a2db815355e20abfc5c6e2afd1ec639760b1880fe7becf072453fdc1b27c29b4ab06a29aad0ac51aad4c10cb50eb607c0573a5b654ce256808026e099eec0679b401c759f7ca9038336b81f4b2c7389e8ce2b5a54cc237950c7c50396fcea95bc610e6de8028aa9404fbafa84b155c978aeca9b11d9745c141404bc0d63c7effb5a2d3f6ce0aff3e9058508a18bd7139c0893177e4a562e54548d0f4794e564792e4cd35af46a062cb65ada3512e5104c7a01e46f76e4b0fa06eb77f32a6e0ffeb8da224d53634540a1ce1729c4edafbe128f19ad15540b88d34936ce5c21c3a5132c1ae390c5c1399d0b9e66fc6a03fe936d642a820d034f4f0f308488da67f7ee625c80aa7d935a18c965db9968c35ffea8e0f1c7ecb33dbf20c48616092613c5c4e591fad0024c2b606fd54ec831dbb0829da9529d3735e1facb27e6166c5844c325ac53b3315991aa6d6a341ef8046d57a62df63939c7b2223f0ab01275aeaab4d3acee008219e612b6b78e846276e8095b4b418a3d1bb19f00768008d21e8bb0dd13dcb0a856a8fbb3a05dd100fca63ee663a0e1c5cdad678e202c6676f24ed1b2dd2c16fe1a15a01958cd036aadd0a4dccbdc90094a706be3cf38fa842e6748e09dd9918b22b2a337ae7b1fa836dd13bbee3f6f9be204c74533f79e11ded2fed221ebb5b5efd4c528f39ca0bcfda989533effff8864df6bd5134ec0f80d76c1dac862a147fe461453ca8af5e44ff37e0df6c8479596def0acc6a07ae9c9f233d292d63454437256b4a1f9fbb08a328ca67d24de679aac85643073708424abc00a28f6876a02a8e34f015487dd6791345990a8e91af7e7604411e5d50aa2aa6d1e777ac9f56ffc9bb036547913b8249cc28d39a5b826f6e8ace8464433177899071ce3e6dc82b13766b1ee67fb4786b6866b97f42cfeb7678e6a92b043b4399c7d3d3c40ea55c0c442a9cad41ed4726844b4a903df0490cf6397c3b1bc2413525e0c969657c77ded27133bc62fde11f3224971b8a13251537f9784491ef1558cf395dd7d7944071147e9c0a374e3190a5de854cb4b82d99cd9aa49f78699edd80300d299f0b476277ca96f0c0b5813f35073db8f6376d23a3ad496e3a3a11f1cab5e51504aae5d34738d9d595d6b85187b1deb4f256f0c5f029df4d97a7e1081073ee5ea63098394487192f5dee4eca716b0ededcb95ea181c105e7ea5746615b27420703c3b8297cb8e0fef397ed32adf7be0264c7a55fda23725010cf118c28adeb6e9008336fa8df18337f3ce687955154fa908a35f283e74dbcf218a1808057be1e16a653d0367ba45a0bece9cb245e28f40f008b1b866066b0f58211a4e3a55f3ffecbdbbe343dfff4891ebbfe2576a2572b4530efecfaf15d3e2a7dbf72358bc0d9adcbcb89e2d5d524b7c20a6a145ddd196607308a7c2234fb17322b36c086b78a9b33894f959365524b343646155d7a8f7c5f21b6dfd7506125f2670c936984d5abc871b96b37ae06c113923e43851db430665377377ddb7cdfd75a19f6fcb94d3caf505b6b4c394a929fa3d437d0078f298d29bc73bb089fc5b912260262a3454370cfe40077128f09c1c373ac437b4c88da78ecf85e0d177e9bab7cb2af5aaa7af3ca8a7693797edf210057a66a6636e4c9d841298eebb5dfb84ebdac12ce571710e6bb76b8456911329817050c03cc5acf9c2119cfe174e3925eeaeb47e8ff4c7e59a99ca4413ded6d765a57189d0315b6bc6b862969781a3f44de7ef941410af6d159ddb52bf3118f7ad06814d55b27bf176cd8f0087f7eb522f55a9c267160b9e41a9c4d5e77a7812cd2a9146cf14b8423c7c3ce635d340ee910ea3c1f1116760848bf3c52d238818b10a0f702b1720b584a8454c19e2c679fcb61bf43ea3105076305306cd6a6656dfc6669c41204a83a3113306de43a21013441e72672a8cce1009a6497879712c31fb9d0b9f17922b303e033b54dee229316c5ae5ca3e1bff7e477a4ba3930468dfc85288fff8d2d0b0216c023ba2db0a4e692f73478c51bdf60ebf6860eb45d144347924bff7b65f9725720b9539bcffefac2ddacb252c7c7addbd53e8735536ce89fa9fa268a1e54411e9b6793ec87fff225d46dbdebed32c2941569b871e8d0afbd1a50d81384bd58c55563965d646ab95de65d21697a1450a01bd249aa397edafb61494c313efde79fa817e469775c93b316b9f7d32a641f8a2195e649452730c3942092c1658486b55fd8e5f15780d903ebbcaf5e10120ecc09aada82fc1150510ef8967577ff0b3287e6c59b320bf2a728c725396ee9454d5423e24c34054cdd5b40f539a4d500a593264a42685dc941d4b23a5b6243dc56be3d944616c210b524c588b34cbb309bcbc09c5ee3339e0f077d5784106f727818d68bb98cddb3d787f2f8aa68d82e88a965221526d6a0e1c956843afb02f447acea0fb614bd66e600ed0dce56ae6d15591cb974286175aa6c837721cc4c84b06d266c810299d4a240c41c27d4e6e7cc8fd851c34f8edfce3b581289b08a5023db651ebd868690b541ebb662eb39bb78313f52cc5276b86ae7660f697cbb5200750fad471300d192ba64176bf7197c69d308978a419aad2f269307dbe5b68a9164d80e1a0fbdc96419ca22f5e122e758c119edc4c34c801b13d92a21f79c842ebbaf3c05cb16eb9c715a06c3b560dc821ac2194027bf3df86d1eb48f0d53bae6fb7913f55a067811579ed425d9b76ebcbe552dbd8d5405b769bb3f64799d2a1600ce9033000d9381251750db6a1ba709f7a121e4c106ed1813b8b3790bee41c0b7607737fd4a1df41d150d62353e4411a2c04ea878fcbdb85aa4ba9097dd59a6f17613e721ec309b9a3713885bd080abf74be2bfcff547180b9068f8d8baa4bb95775bbdc0b0c5e9219b2bb7267087d40ac130ed8be081a6f1824b9d266daa3a8f431d8c4b4c833e7e6a2315c10f632e1794cb7d8e0c8f45b72c5022a5eea2a7e7b669714d072244df8a266d06d61f6f4bfd8cae9b46d7a728374b94b4e52ccfb9cddb90448ae74f27c5a2606e432f92c9dc557bbd1e3129c842ef3ec3f2f548c520ae912bcc5622daf89f794160c994cd2e15a9f0bcf0b508704c75261d5f289ad79f1c964d4d4f8924c4803d020f3b805b933852f2709c5312c591908530d11e237ac6a9b3f397311353f40e936c1475b392f1d870da4c15f18df4d56f4c275cc43041cd0aa64141762df2ce1e55c50a32adfad93f54ce36b2f90af6d9868eb83a399515ee1044241a14204d37b58b9d7dd47a7309d8dba5a149749d72bb44fe53bfe3e0eaef695566cd5f02e6ebeaf9af302feb6ef4279897d140c02ccdd1338118a4b2a918517c0d26e2bfd9a460dd445d4e8f7dde66c2e5dfab0c50a29dbbc3f40cd8b7cdf203f66381b3c146f6bf59099e0cc6648c9cef924464f40838613d1670658748a2a85215e8b48ee389daa28893707693bb746073d10f06a2d75c6b8e38a2c558706ab62ddbf2473bda3924a02d72fe02c32408c2bd513a024c0e536385a4976ec74ea0685968f461327954c0b4e199fc2fc040b0d70e83df25c8fbf1eefca6316be58cbd39d2f572b9a6d7419899009569d6d2fafea859114ba8a4c8cd9650afa7d1d2621291065d84b74b73d3b31c83d94296fa8752a6fefe8d3437aca9003666e68ad7a11fca35d43924e68ab177cfaaab75ccd96e8973fbe10b7e46962c93332925c1468a7eb073c3f5f5a28d533a169cc679b7fade2702080cf40abcef8b0fd8bc172bc9e990e1a7085d50dd9b96212046c39a8eefbbdf511c91ff883f062107195405a17bf77a1aa581554c3fafb966a9f2242ed5a2df3682fce9708e113b714bfa4172d9c45e17c002d57dd980bd6525708bd5231c35bfef46f1db4f03c67e0f48ff555436e36aaa554011a91b7a86f3d2feaec2d57f3ab980587237c5b031dd8406fa7c9329901405d38521e59533480872d0d0cc2ff5cfb12a941ba0cf547c1df41be04c55c3826bdd04d4cfcf7a92c05207ca941fc266da219cb06ca5c432d36c14dda587efd95035f98be828b7e825532f87978717c7c2c3ac9776d281f43e0f96d2cc5ec9a3f09e2271e85203adc55dbfe3ccc6747e859d63f9d91cf984a965fc0eca5e5191a796891d65c9830a1458cc8a3c8347a53eed0429b74194df73891e51cdd906b2c0568afef061a33da57ddad505799171037934c1b9c4d735c317c004b0f72ce26a272ee831cacc821491bf3db941ae10c03b63ab5d5928ffd18906bf5f3b159df6cb54a702b4311871180e8686c0c7a618d139f45d70062cf8f6232f7038796c25bd3498250502997290e7da7851366314d14f8b22337638e0574cc52f5e0a7679fe9f9adc697bb9e5a11960f6b6161ccace7455d752d8ffcc2190e19a9a1f8248cf32cea58eb8ebd2611702c1c9de80505b759ccf076166faca2f129b81f29ecb0ad39723a31439076abb216152490ca33983a95be332c9056c01d8d246d4c0ad09c6d6945da1b93baac130024c8a61da2a4ab4df2678efaf3085c7f9ca70245e037dd7f525ff4de4a6d3b477698debfed08952aaa08a824d77e79d08c0b21820a442379aa90c688355385d9b9a7fa31cbfc39bdce540b72c971b5f8f09a14618b74b7d1b058105a0ba6f388514adfc9b50425178d4e1affa0e226876d2539d525f003339087d407f0c6a683767878a678763fd3b2f1ad4d29a0087ef33ce41e4e7c903861d8474a885e3d9b1acd090c6a228684a9bea102fa207cd1d3186a55ce32e89c9a143b605de5c74c6a9dee77e3d17859e51e00268aec7a5c194ac8cc78c367b034c009146cc832024a8157d413d1e217d0e535e51b4ad4f961e7fb5a6f377fc4eb244cb3dc7deebe06ef307951ca2dd7a29aab78446cfc4fbbcddbc00b99c52f916ea6c1eb7a5474f8157fb0570c0b63ecc09bac464a175c5578f7d85903b2da11f15ef841169a18690624655ab9059a2a0b4988e8a503fd1bcb8a419efd37d7e0025058088420b4dda0c71f508f855891988c63edd5901208a9c121767c06440193097311a29bcc6b739d4d944dc6c6bc01012d1a5f0348dc61cc5da2baa351759f1bc632397d8b7b96226bea9af2afbf04023f54c35dd4f82890fe7c2926b0b41bd83b8977d5e66d927c81856a0b972be7b837bd37c6d51a3e186e8790f3bc810acc1bc1c35cf009e9be97093d89f336b1953014c700c96261776b1a1ed9e3c550e8f2c84d1ab3137d83be4e380a8824abb13baed9aa80e8b3bebdda99b1ad99a02ab6024150cfc414c739e61e17f8d4d85a972c4d0e233198f935741e6fa7911f032bbfa56867630b9d2d54311304e96ea8d09f720bc2839d4e9f9cd193c56d28f3a062f577017309cfa3cdd874c2162dffb5dac5d1a7efb91df88bdd732f55b92400b5da7e795b27e68baad12ef4a5d87a61440972b1f2efea271b393bd35cb64055a4b3071f0634f691dcc29bdc2cf4612dc7ad992e533df764fcec6a2a02a696765402dfcddbe982c13022ccb163a74675a69c57230f5d1df86342250f66af05adbd53ee32e3371eba6d68197233e91bae60104a1beedc88f6202026a46f87edba12f5a9d21d2f7cd5f2e4e0d1a78b6150a4137a9c82bd6dc8e2e3db2dbb488837e4fcffa23ccf3a20f9ddefb4ae1219977aa4dc24bb5307c7a28203cdac9dba23e300c173ba4fdacef23ff9fcb3461cd12d94a2e0eeabe5f78dbb7336e4dce9b578426707dd12f6cf8bd390ae4e5296181cb48e492bcd9fbd9b3447beb713c60286573828e8c71034c3869667d07948a7222711555185adadc6daf69aa48dcccaa3da754b45d1bb23423855d03269756514c7a0b993e4d7a5c1afc300dc38d87d0eae140911bbfbde9b3c02fa29a3dd78e5bc14aba38c458d582bc45f8ff1cadd3b840243a5016b58ef220ece7f47317bdf5094f6df2abd6ffc479f2c264b8309da7f22d45ad8c4713f620d36378d487cf136ae917fc71f5449d7302f0a7e7ad531de99a2db4d6dc536551834a425123e3420364d3d20feb8628487cf92c06dd38e231b666289903ca1b8843477f74eaf9661d9eb8045e50d4331068fb282cb472706eb541b8fe1493b5202448fce2c5b83dfc02922b99110404ecf646e3a2381bb87ba2634147179a2ba8fd34fa45b71bff5120b6eb492adba3422ea515f3b866640dc311c065315eb60d0fe582c1cad14013d5901be54f291c8ae718ffebcbd5cb71e979d2f2f7dcddcdff3e7595c01211198005b8c45fab95005282d8dd0eb404f29f7367ce93b349e268a0e534ab319639e8a569bcdce6fa2fbad1906ff9f6b05088c343d85f10555e03e65cede9b29782f82e1b66c3f888a9ecc6cb72942d3d811dd4bd52e7b9","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"3ce507516cc56ec0fa738732f387e94b"};

        // Save hash to localStorage BEFORE navigating away (blob URL kills the page)
        function saveRemember(hashedPassword) {
            try {
                window.localStorage.setItem("staticrypt_passphrase", hashedPassword);
                var expiry = new Date().getTime() + 30 * 24 * 60 * 60 * 1000;
                window.localStorage.setItem("staticrypt_expiration", expiry.toString());
            } catch(e) {}
        }

        function showDecrypted(html) {
            var o = window.location.protocol + '//' + window.location.host;
            html = html.replace(/<head>/i, '<head><base href="' + o + '/">');
            var b = new Blob([html], {type: 'text/html'});
            window.location.replace(URL.createObjectURL(b));
        }

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: showDecrypted,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
            }
        };

        const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
        const imgSrcEyeClosed = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
        const imgSrcEyeOpened = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS4zIDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
        toggleIcon.addEventListener("click", function () {
            const passwordInput = document.getElementById("staticrypt-password");
            if (passwordInput.type === "password") {
                passwordInput.type = "text";
                toggleIcon.src = imgSrcEyeOpened;
                toggleIcon.alt = templateToggleAltHide;
                toggleIcon.title = templateToggleAltHide;
            } else {
                passwordInput.type = "password";
                toggleIcon.src = imgSrcEyeClosed;
                toggleIcon.alt = templateToggleAltShow;
                toggleIcon.title = templateToggleAltShow;
            }
        });

        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value;
            // Hash the password ourselves so we can save it BEFORE the page navigates away
            const hashedPassword = await staticryptInitiator.cryptoEngine.hashPassword(
                password,
                staticryptConfig.staticryptSaltUniqueVariableName
            );
            // Save to localStorage first
            saveRemember(hashedPassword);
            // Now let staticrypt decrypt and replace (which navigates away via blob URL)
            const { isSuccessful } = await staticrypt.handleDecryptionOfPageFromHash(hashedPassword, true);
            if (!isSuccessful) {
                // Wrong password â€” clear what we just saved
                window.localStorage.removeItem("staticrypt_passphrase");
                window.localStorage.removeItem("staticrypt_expiration");
                alert(templateError);
            }
        });
    </script>
</body>
</html>
