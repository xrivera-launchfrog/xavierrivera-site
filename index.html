<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow, noarchive, nosnippet">
    <meta http-equiv="cache-control" content="no-cache">
    <meta http-equiv="pragma" content="no-cache">
    <title>Xavier Rivera-Lanza</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; }
        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: #f0f0f0;
            color: #1a1a1a;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .lock-page {
            text-align: center;
            width: 340px;
        }
        .lock-name {
            font-size: 1.1rem;
            font-weight: 600;
            letter-spacing: -0.01em;
            margin-bottom: 48px;
        }
        .lock-card {
            background: #fff;
            border: 1px solid #e5e5e5;
            border-radius: 12px;
            padding: 40px 32px;
        }
        .lock-label {
            font-size: 0.7rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #999;
            margin-bottom: 20px;
        }
        .lock-input-wrap {
            position: relative;
            margin-bottom: 16px;
        }
        .lock-input-wrap input[type="password"],
        .lock-input-wrap input[type="text"] {
            width: 100%;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            padding: 12px 40px 12px 16px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #f8f8f8;
            color: #1a1a1a;
            outline: none;
            transition: border-color 0.15s;
        }
        .lock-input-wrap input:focus {
            border-color: #999;
        }
        .staticrypt-toggle-password-visibility {
            cursor: pointer;
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            opacity: 0.3;
        }
        .lock-button {
            width: 100%;
            font-family: 'Inter', sans-serif;
            font-size: 0.85rem;
            font-weight: 500;
            color: #1a1a1a;
            background: transparent;
            border: 1px solid #1a1a1a;
            border-radius: 24px;
            padding: 10px 0;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
        }
        .lock-button:hover {
            background: #1a1a1a;
            color: #fff;
        }
        .hidden { display: none !important; }
        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .staticrypt-spinner {
            width: 2rem;
            height: 2rem;
            border: 2px solid #e0e0e0;
            border-top-color: #999;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
        <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="lock-page hidden">
        <div class="lock-name">Xavier Rivera-Lanza</div>
        <div class="lock-card">
            <div class="lock-label">Password Required</div>
            <form id="staticrypt-form" action="#" method="post">
                <div class="lock-input-wrap">
                    <input id="staticrypt-password" type="password" name="password" placeholder="Enter password" autofocus>
                    <img class="staticrypt-toggle-password-visibility" alt="Show password" title="Show password"
                        src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==">
                </div>
                <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked>
                <input type="submit" class="lock-button" value="Unlock">
            </form>
        </div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "Wrong password.",
            templateToggleAltShow = "Show password",
            templateToggleAltHide = "Hide password",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9f06c97dad2daefceebd6c5471495432e6a0c98c841f4894a9ae46c3441b56b7fbb783e72127c7b48590179ef57a5a51266462bc1fd1928977fb297f81950681f45e93b2d265a36d86f67a5c0eb5d8e5ea2fa3da4bbc9c3874d1b922b3a94099708b5748e36e44a672fcad25404e59d992eef85ca6e3ff540223f017298f272b587103bd3d0b18bd375ac3ea7e0a87482f304809f91caa8548d57f0cc6bd7a8a787511ddcbf39773a302232a21717dd2776d0aa1f7e7531af2c92841a745e6de2e7abf2d4dc4f2d9e0ffdffc21de4850f754f9e6c1d8d29b3a92f3e3b019844e0158b241015d31652664af8aa23ea2f9dba5ad0b4a5829856483f966636a1e6ca8d00b3c43e759dd5cef48cd31554c6b20455ebdc73557227ef54ff3d1dd70dea2fb2104babbc084bf476a77395d24edef0bfb69142c5a5219521aea9e6ba893888f29afc08e11cacb4c0e4cc758c8264a3b48b3655e40c41713a23209e0a31d18f0033e91435f41798c680e8833d36c668692bcaa03d9e0420f68b4ac0841c8750cf7c30e6d9d86b5b7baa363fa412bf6bb1848050678eedfb1f779bba45c20aa2b041aab14b3ccf60191f678c792fb4ecab9e26b744a0c32e029dcf546dfe123212d2452bdc7872f20376643018ca8cb6d7431b179132a3dd18eeb8b1deceb4d631f8f38cc0a8a77587bfa15461769e7614ee8aa5228cc16a6d8535d2f475a3b5251805dd99f46d12152697ec51bd88ef897b548fd2f22fe54c7dc3238ca849df4a15d1f98650f9e29cbeb9ca6a43a4fbd0c608d2453517d62506fe0d6c87fd6aeff3d34aeacffb4415094daf59d1592e7dc02ead4e2ee8db87d50ee634ae44b0afe296f275907b26d5f3fe297524c35865139b5b20a0ad14c79b8b63e2be584e84d4279ce08f8cc86f00e94c5728a4d8da128c41fb702ee9405d316ed8baf5d1353e4c589d7a654c29fa1ac77503cbcf2d2e854a1a05f898f0a3732ad771b95063f3711788e7f20bdf33d6823926407e989adc963cf58a541f56ae5a3b78be8b426f33e373ee295f8847ff5e5ce6b5b574535ef6cfc0fd077d579f79ba18e5000eb0e3484376eee790bfad4d327f2c8652beab19cbf43f987e90d2983f0fdd96b3db90f3f4ece91d933a192adff9c24743512e41a183e364649d60a00feebbde1e68946e90051d7038d62352a31010d6ab667af3d3b68c158b3493e01634b992ed0c4868ea2cc86580c998c49d69a2f6e72c5adfb6f97a54132848c2d6f7dd01a005d84d0eb716633471bdc9cf57ae532ff9f3b7205fddb16b6e4e3430f82a066334c4d2029a33aab410de89a244a0d428a32368fcb8c8df167e5226b7d0fc09592ba2252e273a810f6e823a0127c3ed430a5a96af1ff592815a301f5ba36098bbbb6f07f14236223bfde8262979c1cb5642c6a6b2ca82de4dc75a93c618845740df57f8d50aba0dbc638b7c05564c15190a3a7c0e6e6fa525b6397137412684bcdc5234a8f2cab17aca48cfe7dcfeb8600c82b8d624482f9ac8c9b1e3626d204b7518cbbec34e5c6124fb63207c8ff6cd6e39e68519f4e93a80044c74773c8de3b98266e665372f0a792f818a696759d880602d82d9e371f0e946ed6c4aacf8f9670cbfe6d2d008b8ed91ccbb95eafd28bef08ee65da24b9814650055acf6be0a29627922ac3fe797587b7d6d722eeba0c7a8ab8d3dce649b48ca508db9f0e8c5daf923b8837874ac652e70c7c68862fb62415d018ebe57fa025ce475fd6ddb6782cb479929ae72dd2ec3f1e96f6492b7465fcf03a54f8a8adb7b54fdfcf194ddc68ce2741772b673f00c738840864330a51b8f8c69b35bfc7cdb18e8d77e2d8765a38a29223e6b0892e8bb8bfe3ae21d4552dde7ac1293798a70f2428146cb3d589a62636d51b5f665f72a0e9cfd399e269accb57d30f48c3839b55fe6e7450de6d842581cea5a6a8cd48eecdd2a49d48bfb38e0108dd6088733aa0a258935a259a5dfb2d2cc30bceb604bdbc6682530e417ffd7343e7ae882d488e50086baf8295a9dd3306da7952684d2b3cdc076cd164adb527c89fc55342f258000f2b3e02de49c17aa784a86ff8812bbb3cf75fae086e8dfbc479b4c230daa81762ff01165ed4dff15b50eac7bcde69822938df5351eaddf26ade2cb74838d937c0513258121baec7274a330b4eba5751f3940afc34297c82c8dc9ed8d0617b222fcb77f2b9709e07e46c8ea4ece435f6bf242d3ab409e567ae5e293754dc4135d8a3e9820194dafdd001600e9be144b3dea935ef098ccab426696ccb9820bc398a4f9e8ff0974434071baa15b1541c22360a7864adec78ea42d102729fffb0c7a42519835dbc5cf3918fbdc01c2f88f1bca9056bd19d07d4f3fa1d22d644685eba702f906e89d0fc032cd83b716258ad44613ad71cff31db26e5a1758433d8603ead91a13532b1b7ffeb3954211509642b14d6af7db46c5c56c5813dc33eb745441762fa1093fb8dc8947f2d765490248624a46a7fbbaccbb38652bb137c208cd4f1711a4208ebd62762438eb184da4aeaeb58471e398ac3fc03af4b05714f6fc017c85a97efff8f560dfd7c69df8ff000318db645155145465c77b346310e692d6ec6f4d05b500349b2ac9425a46dac4aa8073fbeaa727ae5c7e8edf450ffb659d6db3aad2d4786d8920075a075ea2d3e4c1dcc6e74692dbbef309e9c195bf172abed479132885c8428a2ac6a778d155a774935ba0f5b235e5ecf29a104c32d74970c092bcb8f43fa0f508315f3f434a93a64e2a3a230edbdaf0021c31e19050487ad7c04e8cf0570435351244a78a265cff56b32f42199f5b8f118e04bc949c72fb7d0a1f5e25229403faa1c64fa157de455ab9e13d1c20fdfdf01ee5fdef4f42dfc76d93d05df4623f6e05d1fb4c2c0eaf2f08a1d28b5bdcae67de200dd1b5cacf38f73aa84e323f2cedf984873619ff179ba09bdcc361a7b78302ca47dff9d509dfc96005c26567fe55b2036b6ea27e8540cd1200fe0df696c980d256df0dfc9113042d21f64d4868cc818669acb783204fb207d8edac2831df16469b5337db84e873faadc0a7277621f702cb02f38f616e6ab2969b4c0d4040cd375d4ef54bc2f5f8109af9c8fdee4082b1a582302bf96716ee8f0478aa0414e9da0bba7f8c5c7a18c776fe243be19bb538732551e5a8215f67e8cef921f9c6aec7230a217fe3cb11abc7c97161b11fe9de68be8fd090d6c8b5dff8ff902259dcd84de9e0498c21ad59bffd749af82820679352c8d971be461fda5fec8cc220e33a10cb0e136e6429debfa40ca3799e4acf7a88ad559fd8065bbc85cce656152ce1f346e9923ac37a7b8ad1e5bb1d37a7b51f0dc4e4de13d485aed7cd72695a505c4cf7aaa8da7c21f629096c45c26ee3073aa3513346dbe974ac77685b66397d4fcf3e90dd37c2cfccaf3fde12bfbde72a61fe2931a1c2694db14f1ce7ebdb876ae3d17e8e869059aae896628b5fb839b6aaf600565e54265a38dfc6db03a060eee6b2f97517718ff2f8791c32125fbad69d0feb4c439ff3abce31c6fa1ab6e9f606e5d85f7478db049ec5c8ec41bcc405504ba450f3d973d997a9297263a61cd10f6ee8498c0f5334dabd8dba9351ebcac9cf4e92c165d62883aa6236e808aab1b5c3753dc1bb4e7977fa9466d45c838daaf9dd1a99be2b11cbd62ecf5eb00ac2d7b9b609270e03aa70dc63c3b11eb291077b0d2eb48f148d06a4c063224a556c7799d733c87b7af83d8a61a208ea93522d90ac265035953003373c88f86778dba82ae70012d2af3ae0cc0082a79c59cfe907c5aa505f8d5abbc4e438b27e654fcfa0a4b7df4816710df743b18255bf292a866aa0b4fcff2612c6316e7b87e307097f75216f44b1404cc4b6c1562e8de3de3b9361c48e878dfd19564fbc3f712c3f016246fdae94e42f4aca9b5bf23a682b977e2f07e72aa083b27de4dcc9121075c44bedde4ee25a2d3c1d7b680ee1abcc28a63f8868b3cbdd7c007d30748a11c7c62dcba0fb495c883fff7e4ab29e2f91b4f8f188e74cb4d5cc2a9fa0dfb30be023ff455ed59046739f1d0bdc105f9e68d5cf60c1799348dad70479b2c0076e4b0d7d9fa118516d6c3a397c1288fb1fc9aafaae8042f09615c8bd114ad71723259ea8b7a98c67586db0ee377e6b678e3371f26e3e1321ccb76cb52828620d76b0c89453b9a7f0d7caddc9392b8109bca2d46e9cb6223cdea81a32a76e08ae17164eccfc44bc3d2aeb4284e577d623da651c6754b1b7d250a5f0d50099bf5ff182742cf496d6e1d4ea0a38c5f4d1581fe1a1900d722eec9c5b45d512fc8d42f93c955523909eff4eca23e7a71425005dfdc0513f3d766061cc8c3504111dbab5ffee7ae0dcb6280e9c7204322e78f7073e4a2883dd29f537404b7109690d513791d4c84759a278365cc65ccf3933d697f0a0559177d80799a569a2de475cb64fe2141379b570667d1156c1ea7ad9ad3e26a60531a68c807d933db0dd857853c5555961ebcb36e5389f33e2f317086d1f90522b1c70d02cc47813a48a69504328725e7715e8a758f0c4b408e8a0ef1e97c0f2c15f379d47231cafea4551781406fc52ef281987525a7badfe611d356e04c95320ffe9a121fa4edde93ef8b646d2b408a773d1699f408820b8c91c0d5085b7199406e177dcf61bad513f8a00f90209d1d53533d59d58f3b2e4df5f32a69f6d69e25ac2e9b2ae51b2c0fc1fd22949c0c8813e5d9c4c084ee0e1b31cff3865745f3ca809bf23d41f8fec76e7d5a0a03ea5ce7f20854da09f93dab03d0cbec3449fffea47c7f309a805b76b84eb2fba69fbde980b1340367aff065193e4daac024e672d1ee87d23cbc5c7dc53af8e958e0e9432e64c3661d8b3e4e0b5a6d2cdec03b8a6a1e50cb599fdbcef1d3672cb03ecbe6e30dc77126b34a68baff9bcba5a465d42b639b58f5ffa97834e0449aff213537cb08358289f87197b8f61138100c29cfae3b14c5f68a66713fd8dd1027ded124fd50b628ca4c24f773e8187e067cba5f63c1ddafd886967c604d85c4962815b9705d047fc63b9afb972b6e5c4867469037879c65b7aa047aacc9ae1f4cbdbaa9cfbfc18192d055d931a0111a43c563054b9e1581be39efabdbdaaa38746740a1bd1bade878ff0329cafaf02484a3e4140060f7cf93f554d706905e407a8778fc05fbfeab2ad514b0a955bbc5aad8562aa824ffc0cd7d4540e239cc65f0a2d4240738def0cebdd5faf57f1aee744cf8835df9bdf04310cb3402fb38fd2ac9535c1c0d34f1ea2a9b9f902444e6854bdc5c667d3b2a1c70f2b03b0ac5955edced96789d2691d7adb42ca089e1e617df99a7e45ba83945be6e6c29d0d4251654348780d81f6c2c2ca022b787e8a611b978384227a2d919b9a1b4c556dab132982f2e15494796459d2889324d96dd4b2693e46bdcbbc8b055582becf564e430f809ef615d7897e36f2ac1847e69fdf4fe69ea4cc571ca308209891e732b74300e2d9c958968d407861379b9a1bd592e1b559230f8471368108abe5308a2df0967530823e0176b9004ccefceda74f1911c559707316157c2a63c5b7199a942d9fc248e3c84b7452fa3294391e60f3b53aea7b21b39a3236a74f5cac38d1d49798ad4031cd915ee8c91e4b77e7c220da5607ece04625a5b266c15fccefb4f0afb32b70e8f6884c1e8398f5978215ec4315914ae19f5952cd6a5d7e2e5a8fb1b78e67107662f074bfc824fee83d556d20573bdddebd531fc9e7324a6a09786bbe70f63728a456f64597f77c243abf82508466050318cdaa311ca589e9bcf2dedcbcbf822ba472aa705981643b3f71cfcec562102556d578aff9c952f0c21b3bca0fc830e8c4168b284c2684899895939626f40e91b1d56d6d39c6a8486e827f9b27e1767dd9d43ed5ec4a5ed29f1cef10959c78759dc7ac37690cc99679a58505667f58a7e0b399fcb512ef7725815fc828642f9e6f78f8489a7c64e38a19191aafb4ab3f15bc55dbf7f409996f068b708ffa51efbc3e33efc7a7025df838a76027e456aafedf9e8dcd8b3e04936e9e64af45f98fa4a2cb128c4538171f86cc7cb1e85465bc135649a518d6fcfaa70fdc4b81c248f0761eb7942d777377224606a264aac3992d03ee58f93238f457526581597755dfd7140033526cbd9b0a64294503986e7f333bbde12d2b13e53ca38ac48e2c490a3e2fae876b649c1b72c62c5446a7bd1ed941c8e173e89cbf899e1700d77e36d6314c17da2b9dd84c336fa5132ed5a01a7db76d00595c14a2c9d1487d70394d3077d417c33d539614a30ca4c26b6d5f7d78734528196275a410a6a64a92825a4d028fc72e44b5ca1e768dc6cab807ba19126b001aac2095ceb23cf0f7371d1cb4c6102f1f260c90cdc654d58914dece0c9fe3c68c7e4af57e4d8e2daa649b6471dcd46692fcd4e6c9b84e776c963750d5b1ecbd651c8fdd725d7605e189943ab83beae4e797ac962760e8f353f09af208e63138751e4210050a41f8c561e164c9416b6d0c4e76eb9000908847503687da73627f4ddf25fbbf5b5f3d8edcdcd7cd08153ace62a6577aae4cc70d69c80af05a27ffc158aa07c1bd28e975e5ff1d29df5cd8275c81ee31e4caefbd2c58ae4344fff79c0afbfc1327fa5b78307a252c4b28b333efe13938c61787b7bd4408ae8435b771e4ae88ba0058880d4bd3ef4154a9c10559e68d812dd44937f6d88792da3b2fe3cea7ea265df3fc467bf526e24e65764c778bc7355e38425bee0b3f340c02799bdd1bdf22251c20344cacf8029681e80583be35f9c12d6a124ef8baad936e67ec6f6ea1ca4aef82578daf42978010d5fe02fab0986c860c29ab9e70108ee11d6d6d3236eec2488c472a640a087789978486983952fb69084331279712096a01c143e4e6b04022d7f6ec185224520f22eaccaf4e359d737711630e1df1c81949764448f95ed72264f10d652b7a135d5ad2941eef19af746c23b14eb6cfba5fb16206a2fb49fc3973de663beeaaa8041bc52f3b54f74cf928f256bf69daa20fcf43b2861fb63adc13b9f19773a34c3eea4141f49172b974105b7f8c315378da1f10ce98a3384c60d6b05312d344b67be4d4244f680ad5e93353c371b1ac34b5b7e571383d5aa397c641acfedc5f1bb2f1e2e4e2f2362efb24374b528687d1954336075e33be7fee8cceead32024e1bbc9b80488215ab2c2b4c871f149cf505dbeaf79ec3a450aee8f170a422a361b495547c64aaf0928ac7a0498454b25daabffc883b21135c3f670b8bddca78839c1b26df30c14d65e9be120eaecc37693ef2b5c5a918e002f566b8fc080ac81a98862a4b351ac19f9193f607ff1439481bfd361b097fca9dd0cf0c9c9580b33fac17f04db5ecd16b6406333ec591f256c1937d37d5aa167f7d5cd0fb0de1351958c64a7d2fbea2a7c8db4d89741ad0ec18f896bf3551c574929e12c8660f71fd5378d90634de71a41fa79a928d3b43b82a1fe7ea13ac5c2c6ea5cfc44551c54af494c9d9eca0983160789bc3703d14f0fda14f11eafa55f83ee7286116c690cbae3eb6df26a63d940f20fc573c2db8c8c385833e1463ebb5fc428c8689b5bae304b2bb7bd19b261b67fa6862a304d0bbb87c8edfb466ff67e7edd774b156229d82d99d8be80214a1e6614bb2a082e998772d3368eb43ccf2d1313b0f7c928bc901933c21cf2ab3edc837d141fb7d234aa6938dc2914ad2a0d37d919a652584c03854aa3fed68b159942a2377b6c52ce0ca92bce2ebfce50fda50cc75497013bb69308d454cd769365901472673ca4493e9b99b70fd91bb3db71fd847ddc333cb1351022b53df50548197f38caa202971880021c3baf2690473f08df4e62e985320081cd41e4f88a2feeb1b63be6869e6a31d36f63e62850e81c3bda8828e1d4a3aee4e738d79857f767b734ce2b69452452cb12e8247dc29cae89baed4563213ef041a6c401ba9859d77a94705837e5f9346b94c6a3230eef1899a800d7c634579f0984b8d84618498eed6aca4cbdec2cf34ca818a991905668cce013c88bbaf6a2d2879aa14755154dddb697f3ad78e0dddb8d0ebc0769065bae7c899362959a44d138218fb04b335e34bc60c43e468d6be2bcbcca27ef2ad8485f4447e94d387b3d772ce7822d1858df177e0d47b195ab6e2f3527d2db1b6fcb41ceb5d80e7db722b4d20a55cb2e9ca3479bb9b5c7f9176e3ccb71ec3c39a37f9c72d36bcce21355a59d53acddefe751f21e4b29c4e2d80140310e246d3b81e654ce1cc756cf7e6799493ec2e74dd45bd9963269d9a1aa2e14617fd00378a51917ac217832c1b92f8955030c84f8689dfc45ca43a41485946553b2b754a4a083eeec3c207c3858c18375ac7969f5451f2e3b0d03206bad96b908d03040d6eff0d5534c7c4fe300c5ce52f14fe6c7c086f6175c65b39cc9ed1a8ca68b89451782f09edfc3c962fcac27e8d5672a303296dc86a144ecc33eb8fbf91b8c201ce77cfb645d8192dcd2f1ab98d787d8e58a9badc99fa17ca6d2f67adb444c3c5ebe84475725b99c6ad6090ac4785de694debd9bc6613f4089efd83620eabfd2c0ba61f09858e781dea148ee7b742b5bf1ba04c679a3f","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"3ce507516cc56ec0fa738732f387e94b"};

        // Use default document.write (no blob URL) â€” keeps real URL so links work,
        // and lets Staticrypt's built-in localStorage code run after replacement.
        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
            }
        };

        const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
        const imgSrcEyeClosed = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
        const imgSrcEyeOpened = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS4zIDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
        toggleIcon.addEventListener("click", function () {
            const passwordInput = document.getElementById("staticrypt-password");
            if (passwordInput.type === "password") {
                passwordInput.type = "text";
                toggleIcon.src = imgSrcEyeOpened;
                toggleIcon.alt = templateToggleAltHide;
                toggleIcon.title = templateToggleAltHide;
            } else {
                passwordInput.type = "password";
                toggleIcon.src = imgSrcEyeClosed;
                toggleIcon.alt = templateToggleAltShow;
                toggleIcon.title = templateToggleAltShow;
            }
        });

        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, true);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
