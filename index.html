<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fe124334f7c7176c00415466a19357b69a82d846dc7b9499923062c6d30c0230b3855c12bcf87e92359c537b306760c82750bd636007266252b493452e00af2d3b8117866276952c831f8a52618957a81ba7c20a3356449c4df6c2bb1e8464dc37e6bf9ba5baf4e58cb464b3c4c6aeae88c2ba114fae46dc8217bebfc8cb093b47563d338bc657fd20e55d8e5350f0283ae7152bb265fe714a996fee1762330c830b52a8fbcdd719a1a90aa9889544dc04a136b783caad5cddfe5d2c2f04d6076b65722b9be387a981c6260ef372d1546db1333afb8699c36921c610022d7af7ffdc54852f1399c4873ac8cbe4261d1eeb7acedeab98008f2a996406f8e8e35966cd3a3f22262cd518c8e08a0f3be23e1b8db41342f48cf6c2da7c1a33132bc149eb22653ae7ba1ba6c072bc9de4cfa60ae8f667c26157d2f22ecfd76d92e159aa8f02a396d563069c44f1f08c4b39e73a99ffe61413bbd7824a287d18fb25e618d268a01240c3b9cd12b4532eecb7105eceacaf886b4243997718f973d1cd6fdf844aefc200dca5b7e4e1decbeb8a5403d8eb918ff582233a25d70704f5e3c7ccc89884b1e52360709b7ff190b4dcc86de88bda4faa50e358783d6f228a8359b969b62e21f111444f33d14e2709a6f146c4e80af9a2b7ecdc85552008d27253f6601b81ac592574b75c8690e4a5d5428aea2840ca04065ba4bed956d18afd3da35faaa8b766af5df493e0c171225f7052fa467a426cf16b9a92ea05e7e5eecf6540a240c688845cb72faaa7b45e9ee418b1316c938060ea756314df835d775fd13d2079dc24fdbc44984a9ced16af4cc6e7b898601a5a47d23caf68912aa0c505993fc468439c6a372404c65409d218d40e4ac4126418ca0c8ef11a0c8012b4364976fafaec733bcdf9eefaa5c0374c5aabd9210767b8b1f1fc4cac9a29374dd597e00d197509372ce70230cb1598f5872e3ac1a33c48997055f6ebebfe3640e90da5e8916a02bd84f413f18f682696ce16e9fd54e048ddc4d37d3cb0cde811fce98ec171484beb1ccc57a32b8af86d7b43a26d2d0caadffaed1baee109b2ce954d5ce63d747de34fe329eed9c2bf4981c07d6379f915e652dab8c332f93dc46086b59569f3979624499582c26eb72c202b1d623285c5d0a1b5c94f27db36847f6fd785b401c6c78985ae448c82cad3ae0d90c2997bb7a36aab298e8c898d8a1da8190c2c91457a70c65710cd608cf1314cac5f1757042c5a431401d18a1d938531c350fbec4dfe77140c369c16b52f1efa32e9bf77cc8357a923f8f1b99d3cbb9fd6e5d1a196d821df1c0da221a351be79cab009f95c06d418d34a2b3f9d5a1c79efe81486eae52567c272ba52e3aaf24891ee697640484abb070220f7a13006f97ac43a8d1e19b90aae98000257fb602e30c6965cb99724ba6131f25119bcdcdf1767f3703796d96e53b337016bf8db086a693a78aaad7045638c2afeda80cec6db02bdd05f64812a864885d527fd6279916f6708c53c85fdf178f781bbb7124c7eef64fcecabf9fefb38162f9d89f43626fba165d7f5c497a2427b666cd485bdcf8212244fa80e045795a0829da1f9dde0b108f3e9b8aa0b7094f736dea48c2482c1873976af12d596adb253131506b312fed85d5ae854a494fc83b7328f2ed21642533a6532be5ab780e59746d3fc8fc2e2489c2d7ec80df8acbb00e315d94c48075373078be21c15bfc5faec492a269ed55c9735c9ea5c164a9f994905f7dd8033b454959fa07eb26f0c4db30296ef1225e084cd8808968b68d4e5c151dcaf347a811b2c73fe6a80ec3d534a59dd8dd16028c09ffeb43af2ee39465a4f03e564ba8bc1364cd6882cbc53ccd3e4a6b9fb67850d2a1f57cf9b947f16f303a20dfc9b5aba9040ce5cc47531a719c91bbaea198571849fe6f3b4211300275c8d28a7181c33a9e12806fa44706945ec8ad0451920088288d7518ad4548b032717979b615ebc6172af29c61a25d510592da1856713f0aaf72d56bb40e1f0627c521fffeabea5800b01679c785b0c0f188ed8193318f955d3968b6d2bb1230f25a0c272f0a061953084d749a2edf9772e430914346100f4d104067af0cb908d27988323b8fe37f1afc86d6e328dbd8f860a0a530b97f4d23623edfdb6a4678df69641e9d947510f92cf60c2726158cefdf1b9f152bc7c1fb0b3c50f1c000308ba4c82679bf0e06bcab4bb37bf0f3d3e8ad033a4307bd779cf20fb28bc13d5bc98b646f2e9e9e8e157542627acda269e89fe332b83b21cb9f0e2d850cda471c757237bd183d869999f6c47c429329f3a07c415ba66781160d81cffe7f73467060742c52f75bed1f86aa3192757dff34e603dff642073d528b5ebc5fb4f9245e5657ef938dc4ffcd06a2e582de346e796a67af4dda33c386b920e3fe2026e65c2afe7333a7e85acfde2e51e2caf148bd7f432d026f0bcfe375f784298e961679456906def4d316d46204e5e10cc334401b72063ec92d893598ff57abb2d0fc902b9a7340a0e1b2244e131e607cb2ba284c1b752b21967e2c81331a0c52d8eee74405043cf63090d742ed5f692e795539fe74d7d5b6222e49d231da4e4ed59d57b729d5d7f41f321e6d59c77f2536ce6c1c5a42acf2ef792875b68801384455fc08b1101431078dc8a568d15426a472cb7623e6bec3962bacc319068716e953e94b0f996729a73dbea1fdeb8aca91562203242b04e74bf68a8af95118a3d0e71817d4f11b29a602ee965b624eacc05fea874c2105f52814c5e2bdc4686e7bdeeafe88978afb2b9c87d3f2a33e36d74aacec506004f5042aeab7051ae8147941a0ad120be4da18d9d665706497827c1c60c0f5aa08e681c0d5853adee686068128ed692483718215ebd2b2016076835bcacbd5e7aef1ccf7a60405ec9eb8bd8c2d6302bbcf1f51ac2eed9ce4015635285ddcbb9e5f8b2cd49faf37821e29927e19ad694462d6dc9b1b2406258bde72a6cce83ae32b2ce6d4c7170b66088b46094f20c6f97a6c8a7f59e80eaf2362c67ce3e4641b77f0ee56285547d5a89f309604db9b84093d05785491c093168b1e9d729ca867b6f16800c56f9ffad43cd3469d16e4dfa8bc294f91d9e33c543ba26ac4a6aef07c7ca6e02509a633b164774cce30d900fbcd37dffa04a01841c38ef4b3773f6f1eac044a523110960b84aa1dda6a573fadfa2b29ee14ff4b790dddfd36778ae4a5a14c7789bad1006582c6c7fd457f202a86add0b1b0be2b1356b5fff1c5acd619efdeab06c8dadf6ee4f827722a62195035cf2a62846c68f29dcc98e22b67a056887a388b37cee532f1805eb68dcac9e7fdd90edbaf5173f3bcea99ede2dbc5115005391410318a91152d1af744cf1aaa06393443b2267859d555848f4d33f06c09d4d379eea303226ce65e16e7b19ad8663fcde5a733fc9ae0097b2713d831aebc7a24b13b2a20293ded94997f42a8021e0daeec717dbae5ba897c38d9604c32264afaa087983e480687170a2ecdb79e01a5b38e7b9a59585dec4f06bb295d100f1246b4cb5adf5320f40b53fe4bd6dc38c66daa6884ec5f72271ef332f139cf4d1d68320d11c4b7cf9df2da87a89b4f7722d6cd5137115cd048c99445648651ac23bca6c36b43081df9cc1c8b3440c710bff0db990b257abb45976da585789ea36ec93f07b8604885892549c22df99069c4fe53e713b50b32c12e9b6b5a204c75f5abaee938130360106a352f65f00080be02622231b8aba21cda89c41f1524a3791b8ba76845f54ce27ef1bfe3a9a8c209c2d67c3d22621ee651583a3342f56807d5160bab10a7508965e905369894fc0e75fca0d63c984f07d54c10a6f211cae439cb17e1657ed45aa6914f5e70815f0177fc92afd5875396a38aea0e00510a62680a9c75d2d903842e776861b4887e81570a45fa5cf7f9c341f400ba59bc2075bbef2619b8b45cbbdf6a7eacaa1508ccec4385e5c968190f6ed97f9d0736f801f0c4029a934bc9d64fa4a2fd85590edda3152a946f44b02920f040776683d022906ca0c4259a7d2306e63e9a499920512ec85518b435e3bb2a64cf7e276fbd00abd4425cb63598a7ff15e6014798a95406742fd58766d7d8bcb6caa39fd74a8e2d3674a6d76c0db6051b8383a92ac90e0b67252893376e3338bcbb420a78700efda88a30c68a719527f03ccfc7cda30a7efaf82def58fc32cfddfa7ac8882cfca213c96ac30d35ac6f36dff4039131a9cc4143ebb670fb3c64888e281d53a5ac9ad42b85ea7ea8a63fddac88b184678e039150705da481533159b13cfe2cf32bf36141da2f483c326313c08cbabca0aecdd48655c91d71f490e5ca772781a3755b78e77381934f5316f3ee61922b510153c8277732037689b121831c388db47e65a9c5c6b9f05cf51fcf842c26f78565b639919f80470548fae53b431c41de5316114b4933ea65f9c0686b6a7d40b77b27e7ac91e815761bda87c509573878e9edaa0dd24635b42a78bdd00c878ff6347f2c363c5711943f64fbc5d71af43267319936b91906fc5262c1e6114c4bbcbf9dc3da9476e9deeb495ecd6804f1b689851aab96c4b6b7a268cc2bde7a98021f6ed5cb352e2e0cb9ae1058660c22120fa45fa33e499dda16f503e87687983db63272a9203185b95c711bd824a8d0e115998ab9e980af246d5e1feaf753c419a0797a509f240242789f5d5c3c5d6281f357681cacbff7b17b468872f4fcbdc817ec283e33dea541abb8efc1c0ff7b7954c38c109b7cd733188ddc3ccbda0f3ce0736b667f2e9a4b20249cd0421e4ae7ab2ae230c80563638a931c7fdd3d14c532e02e5a8825a0d9e9f38a7df70bd1cc0fef95d26f53585eba7014f236d7e35a326c577d5b4a7d9cbdf03fa49cf6a99dec6159b6b73375cc67653d76a7553720501b4186dc29c4520f9b17f66d3687377f522725d5d7253d6c7283e12eccfc8c1292ca40cf3c2940198ee0fb00e1b49b591f84487bb8e0abf8ad1e966ad42cb4d6f86e7108588ff9ab60c8fcbbe4f0d9857aba4e695411ce8b08fedf6f0f7015e6094fd6f0b4f5583d18d155e9869cac38115e07ed74c6879e0cad45fddff8e523e58a5eb1a07ae141f6b8982de82d562fac44684b4974ec13924dfe7d306c741477ff3c92d9ffd6c5b6f273421aa097ee15f1149432e7f721d8ef88ca287d5791c8370d1bc615e14f4ca478b09ebf40baf287b9ea4b6abd360295efdfe001209914e6c94502e96217493527eb3c3a166983f721f0834c088209236b97ed7a3b0bcad7a2b70d6b9888238d1e778e8fb958355d06c5d1b26bf65cd94311a9732567266bce937031203d3401ffe3082408b20197e0c13c7cf99e14bd666714d15d7ffa81717bbf9889d1e1981dadb15adcf214e193868e27fcac516fcac9d3cfce56780ce0144048ffa51e49b134e9948fc25a9f9ebc9ed7fe61e38988a76f746373aa0cec12f27c5d9a8ffadc683b4c74835ff7caab33e3b45d668e37473dea19f3a0a90d06d4e2c91b038972651af4a9910469b0041aa57aae9b2a2e1208202070f2abddd20669c084fbed33f947b03058bc982734a08123a1449ad58d65aa1b0fe28dd2a8cdc8c002774f378e645083c2db321a35dc56ee087080ac6a4baf1833c6cb5e67218c286d3073aa1df449c9a6105148fdd3d62e89be6b0e652de2dd5687409a9c13d2009fefe7d4be3c3c51a1b5a7455019dc07cb6e6c5bf68559b6bb5edb88f26cf173361333bed6e9ea03a322cf4114c7e118f1afdf97500438e19a9980ead2bf0ee5b180fbb1320d4f5f5a928c129aa4af5fb60ff24824c16d3889d03f927ec66bebafb39b38e74ce8d70556e6d1578d75f2633e40572864e1fdd8e639308fcf4deb0a726c920ddd0b8a3d9770f0916c10e23297e2ad0fe0bd2fdfb0438bc8a5bd3bd89ae75543d277716b55c202d07b8ec78483c688a7a7846a11004a97149125b79ff99314b21bf69fe2908c88ad26473dc70fc844d2f1f08a84ad11fa84e0f80dd1951073ff7d4f4ce7f70be6a360911f10fea691c6467a8be21e94e2d87660c7ff12a36a6e3277b55469e75ab06f43397668bf7e06e8cede027e7431b578e7f51bc616be911c53cf3e6cec28ff99ffd3163f8c2b15f8f5f994d3dbbaa2d76311162d862494f6129671b8e48bbca74614372c2aa543dcdf1c9f5fe2821ec392d34ecbb8ac1db248853016d39b539d664dee0c8e65ed292d4c36e358b52b789f065b8c696153829cfd17ba9e53275c2af60182ead4464eee9867f5775dabdb87d59b47e836b19479c10173397047310bc7852e42a42589c074e783c041582f45f035efa20620be66b2463c9ec56be570ca98ea3a868b6af9c22219777047e487b12c8e6b6b90f29e062c16e3efae3f8d9607dbf2db33c657ea1c7ade2c34b02f76275e6aca726a571faf498140aca56b8e1ce2fb2aef43144a7674e9f0231afce8a53572b04b733bf3f10c3ac23ffcf276110af2f6d49d89a94b7a3eb48bc142086ce437cedde028f04bca021ee7cfe4cca16feb2102a5c15e9c5bac45249911c9e38f42b1e4035d7feab988a496de7ec9e2df101bccd4f29d5dc754b4c8f67003e475858ca386d98c0f2063c9c8bd742f5db9a24af78c9dd12cba6e45d72d8a2554c437ac6230c6271f2261667998bd980f7eb695e1f8b33177211fea9ac1ecf5ed56484380b8deb3c95357fcb53738fef015bcd6d2a5211ab4b22e287d6200b52cbafbee2fdbce2e1b6111e887b23b1d9348c57fae44debb4b9c9ff175d1a92413405f5908c4748a4df99bc8d822adf0d33abd88bdb8a196b49fd54fc6e8f0a6a2a1cd7951b0fc54cf9af643abeb1d6162acb7753d11a4bb43b183790d57b01568e1e511b7b6c12639cb95543803fc774d425c2b3f430f9db7946834c8fa9ed03c6c8036a56204754e763853ff9a10e0abdc4fd9e380f69e194370e3a074e65207ef3c04281b5f55c054f2ccc1d5fc34644454a92b38ab54001c656b038dc6692431d8050fb4e442e09a3bd2b5188099bf0b14ad5c2d345d203d06b3a644a4f5cce403fc33101d3fc29f7d09034c6b6b0cb7b3cd440827ce281f3904d0e0daf972189a5ea74f576472eea07eeef270af5097d4f654ac5490e44fbde069712789f28918dfde4641bb0bede205bf897b0002498ddc7e5c698595d8abfa3a8d90d910b981c86f103a354a7adb7d4c307e91858a1dd8e541e8f7a93f6425879e94e5fe4e169dbfac6ab27f37efd27970a8b215fc6323bb95cd97c86934d50ad8fcccd7d3a68dc2d241e3dd99d180f1def7a3dbd03de34a8d7ac1108ff8a3e256f90ad3dd46c2b911024b2f3d74d6d829e1c0dfb49ca4d31c0f8518e5ee7f6d227ae4de290a6c55b9fcb765b4ce5fdbb9cb0da3dca97ac24f81c8b90af0e153664abd84d7342da1e237922cf8d9ea5f1a6571c7931b1f54749832b010ae218c11700aa8a5d369b2ec6cde9a8254cc6ac08f2f8ceb7b164bb76c2b55be70bc9063286ee722d58db2d1e2fc24f84755b22c05dc1acaf845e397592bce4c6c6dc850b97339063c5ec477283cc66bd32b849c3564ea6fb7132f7bb270703c71e47fd7ef24439a1620cbfd202f7f8b6c88dcce2113f0ce704a3b5fb0a417894bbdd3bbef9df9377fbc6f9d3e4f8882a78cccf0d43d28da5f128ffd26f1ad165483c0ccdf0067f674cb6a0f682208ee0826136e660de2b6616523447317cdc70ff660d1bf54aad09d7462a54415ced070223a643b76f764c2d6e6230ea706530b27bff1a6b4d6e226dca376d49c80a214843c187258936e0f35579e2adc9a6f956cf99a1e1a84d81cc86db193131cd98b0aeb227f78bc779a80d173bdeb5b5015fee0d548cfe3b9e8769ed36e5d8ce8cf32b3d5bdf26f0b57f70adae9d2837d865afc46631700be5e99d4cc3e3ef47059a5192c118d8322fd697f239f0a482d68dab944545176754ddc6772fc4d47a74e9e8c74bf131eb891915e5b67aff803c2437a33e8a6641e1fe20b6481c3135c8af80e59c2c2dcf344c17a9cef78e28526017a6182d2ee05fc5d5da33d0e48c2ac3954b4bf23450186a687970d19762ce834cf71303dd277f64daf43af5566cdf20198e18043c3dc3d8f998a603d37036fd8b7220378ed2bf46f7375933da41a3ea9db8d01c8d857d75247bf1fd38e3b415576063e3eeb72aa8ee36dce29581c2320168ba06599bc768af9bdf02864ababc63526853023e67c6ceae75a0072b31178062199a639f2cf1eba830f643fb58227e62a21e60246a394980260be2087f0b1d66f857136a39686b29ed1a808331b4cf675a03df1d7f8ee3d9838804d205b2e9e713104f7300807f05d7da9730d04c58e89ae2a6e1f29ecb6757ea2002490a2d4efc21f392cc1303421947cdb3ebde43d6210c285080d52ec414f61f856e887a8eadbdf9a3c4be61fbb237859b84a02bd87ab3ddf1676dd2dda4db848996e16fe40230747ffe02332dd89483ccbdf59bc2201fda44b0381b2e314b76e963a06e183d216741cff617a0b2f98b401200e0b28546be3112b035ad09dcdc113eba5b313e8492010ae1bc04ef0cdeacf57494fc5ad213e3bf15022ca51e91e269e87cb0a27afa6992a89e57856e597cca1993406fa192b77dbeb44db3dfff2fafa070d927a70a257b5d312b1dea371878339252eb8dbe3c0b8f9b4a7ef99673f96e0a2ce082711af17cf557d9735c68418460ccffc82ac3a382760a5c95f8762b263d3fc8ce895b97855b036544a16d724ed9df0b6356303451b90239b7725d40dc0e937f7c5ee96a77097bea3ed71154ffe36f145d6aab6a1de41d9d21eaa7be5065423224c4c1c9d51479f247d9eb6f1d11c8b6d4afec2d7c40e080bc56825743d1b472f60b6a9ff6d901a6abd14b4ad2921356477bdd63fbc620f3f7b11a74403ab715ed9a856a29a56409ce6d9bf24fb3e8e6d07ee0d736b788471a3332f52963956c9589164bfb29adb2db0cbc1ff031a80eaa3cca0668699df0b5724e6b06717ad38dc019076ff257b8f233e13986ed4c601fd3df5e59db91e876f3c61720b651b40b477504461339c27c106d4e83507413ae7a6df12d31f3fab5b0abce6951ba5f572472731f2ca5902f406cb5cf4189717f882140f259ac34b6cd58f05addbbcc09995c41a61164c6fd8622adbcf67340959f67a7ff25edd58fe6870a9733aa20b028556b6bdbeea14ace9dda8326839fa6dfec8020bde57b9daf20cd46d371e9389dec5d8fd3152481ef8490191cb62fbc0b357ace3907f1bf3f473793ec34e6a5159db173125e790dbc95cc7a8d431139b3fc82294dcd1e9fc687727bcdf0f268b1a152efec6b4bc431d086b8f18667c5f38cbab9c568fb50b0006d63d89c1c7036be5bd72ba7ca97142f3a5af117e5265c02bf1e4b1d04c5ee87db8db383317ddbe8f84541c10d3df7f613346a4a814517d77e5f3db6758f354551090f3a38864828d022671d58b648e0d6ab93313b33c6316d8f0f8da9ee9a02d4fe2603120f743123e806","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9993fab9532b2908add57b2690ae1cd1"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
