<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow, noarchive, nosnippet">
    <meta http-equiv="cache-control" content="no-cache">
    <meta http-equiv="pragma" content="no-cache">
    <title>Xavier Rivera-Lanza</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; }
        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: #f0f0f0;
            color: #1a1a1a;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .lock-page {
            text-align: center;
            width: 340px;
        }
        .lock-name {
            font-size: 1.1rem;
            font-weight: 600;
            letter-spacing: -0.01em;
            margin-bottom: 48px;
        }
        .lock-card {
            background: #fff;
            border: 1px solid #e5e5e5;
            border-radius: 12px;
            padding: 40px 32px;
        }
        .lock-label {
            font-size: 0.7rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #999;
            margin-bottom: 20px;
        }
        .lock-input-wrap {
            position: relative;
            margin-bottom: 16px;
        }
        .lock-input-wrap input[type="password"],
        .lock-input-wrap input[type="text"] {
            width: 100%;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            padding: 12px 40px 12px 16px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #f8f8f8;
            color: #1a1a1a;
            outline: none;
            transition: border-color 0.15s;
        }
        .lock-input-wrap input:focus {
            border-color: #999;
        }
        .staticrypt-toggle-password-visibility {
            cursor: pointer;
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            opacity: 0.3;
        }
        .lock-button {
            width: 100%;
            font-family: 'Inter', sans-serif;
            font-size: 0.85rem;
            font-weight: 500;
            color: #1a1a1a;
            background: transparent;
            border: 1px solid #1a1a1a;
            border-radius: 24px;
            padding: 10px 0;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
        }
        .lock-button:hover {
            background: #1a1a1a;
            color: #fff;
        }
        .hidden { display: none !important; }
        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .staticrypt-spinner {
            width: 2rem;
            height: 2rem;
            border: 2px solid #e0e0e0;
            border-top-color: #999;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
        <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="lock-page hidden">
        <div class="lock-name">Xavier Rivera-Lanza</div>
        <div class="lock-card">
            <div class="lock-label">Password Required</div>
            <form id="staticrypt-form" action="#" method="post">
                <div class="lock-input-wrap">
                    <input id="staticrypt-password" type="password" name="password" placeholder="Enter password" autofocus>
                    <img class="staticrypt-toggle-password-visibility" alt="Show password" title="Show password"
                        src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==">
                </div>
                <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked>
                <input type="submit" class="lock-button" value="Unlock">
            </form>
        </div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "Wrong password.",
            templateToggleAltShow = "Show password",
            templateToggleAltHide = "Hide password",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"09095250acc107db885e02edf281db7979f13330f5fab9ea4baacd12f96cdda90fac13b387e69eeff76a4071293b43b48a426f95603fdee434f49554c2701a1759dcf637fa034e360e6bd33a70e2b3ecdce35425811cef2c822c3d628894d1fb0a618ececd1fa5ec8a8409cc4439d560294772e8542bc803315a35feb8c9214ccbb3c5cfab55954f329fd42abe109cb07d2f8b009ab063d49b039ecabe07ae6aa1a3fd7dc4a5704af8227ec7efad20816e9481a0c16a01d4b561923dcede8250fb62688c8d7f8ed299efce2a95aa5f337d861eaff7f2b80c89796a6d5e35fc76ee67bc85f455f1de4c506fb4c85d71cbf8e10e7ed164f0ba3187c118ac165ce49af4cf44623b0ca84e5e88d0fed0192827cf15c7d832d3ec35fb3d41191cdd55846bfcc9a2ba6ae800244cb6f7b57da01ceb3d25771a298d53d1eb215135ec45630ad52ce2cd3b2ff707c418bc208694ae90014059a7341e06756113d36448f8b32b38819f6374a01336ca4a2e9fc45ad43c2026a429e7acbaa9be8b1e60e22651f305e2605a7957decf142de5d1cda029aa9d3cb00b0ef1bf0077918bff40fe068667f83ad63c2db6189ebc94cf1ab210262f76bd6b87e06da81df841351d84928cb923c4f0f469dd0e388d006a9b0735094b3cfdfc5deb8131d4c80cefe9555ce719c49b14d6434a30e12915c7adab89d9a3a326cbb1ee04cc7fa7e69144ea567749197f2660f1d6a9dc14f498523ae8ca5003462541464776962b8a9facb72501f5bd02f64f3e1dc3ffc4713ed0461aecb623e528c3757608cddd62ca1a912db5bc2f69d4841a0df1e9975546029b67015c2f9e5933bad0990357879f358439a65030042759b9d1969d3ab1bb70bc80fde0d054f6b4dca0a8ab0aeaf912bbd6541909133132cd00f4f22057bb6463f89bf165de5ca673552ff02c3275dd42e8fa4f120d24addf370c04bf387309f0f52b9fed95b43e78a5c3f86befeecdec5407b3195075c9c5a1f34851c0fb572361ba847d8c0bbb19bcd8a73499b5cc163532219cbac9b9db9ccaad6761d932d937a4cede75783142c5a2ed82d1a4685bb5b44b9cdb8c99fc9a6331972713de320b75a04f2fcd4e3175c41fc9cae66b0e67c8154abdbaa0a728f1bf41be57b6478588e9c688dc01a24bf4f8303f1e39de72d6c88f47b251eb02625aeebcacc7f6cec9db45959bcc76878f8f31062a75c0e65d5ce3cb1ccf26f013bacfcf971f613b1f662b7d52630875532c594e617d5c60dd841fc8657b44596f01fbd6711647437768de9c040e4a7ce119a1f66d07e7bfa1f7e4c6816b886626715c06f95f76c2cbff49ebf72e866a93685725e5709d6e9b037621b6fc636609469a7ef413d5b10669fe95b6bc3111591283134978d2606fe7a89480c2d1046d8ba053914ebb9b0f35c57151cfa0246f093f8e955f950c43bda818a79522d32c4ec72a03c21c863aedaf6de7b1731db35680e2a632cc695c7646be8b192191aade3288e2ab4f0102d0d369eb264f7d07e46cb1692474589e5e1038aae69f5bd9db3915a78c9fd1db26a6304d7fb53932e66d354024eb52352c5ca4607ed14e83bfdeefda455b966623250fb8d45d75c2b588677f97a3eaecda90c694c9181a10d9511cb14d65316ba16e8430924c4f64644fb909c5a4047247f8522885f4a0bdbe77bed09df956a0ab2ebd8dd94d2cfaf63d1118643683a4a60d470b520c675eb534f9abe25e6a92ccdd390deb97cc3c1136ca9bc21c8aec02d1c06370e134a773beb124db53f258eb7bb4d39e4e71120eda6c4c029d9d75db50ba7c78936628b267ac6b3b02ceac8813ead91bf7ed466505f690c9f218072a4102c6c116b9e51772326ab35f357046a979b2b4ee2d016274ea383d8ad5429904df26d82def7ddb6e8a9fa0426904a0aa4094572bdfdcca97d3b33a70d8724569664033afff52a8b527254b57e14ab6186a1d06e49938fbf387c5ca96ce95b21fd56a79f4095e5f11051213f913460b05d28d3f17747a1d724927328e0bb7fe81a1be3c039b394c1ded91b31797bb91fe7950151bf04f800f5166b946748aba97804cf28cacebac70810cb808272a4c93765694754536fdf7b241d21b556b6e4a4cf50c1bf3a31838c7cddf7e024a65c837a3e511932a4efeb05b56a13f1c68ac698d1bdc664f358f510eabbe11eb64ca74d9a50d1b6652ed7758ce888de3246d9e5631e944b1ab34e6d0f54589549ec649eed8f405f6ccdadf18fc179323932d49acea908fb1de86d2b48e79a5a7a9305eeafda3f6b76876f3e17b24e459148b313191df116f6fd6d6e5fa5e38fd21f7883504514068199059ef71d6253947ba9f15d8314bfa5d251a3f23a02f0c85d5c993a8138bccf89632b637750daf8a534aa18b647970d0862350966328a21a3ca4b671de7908f647e9d77731e07516acd1d0298da147e8ad1fc55021ce55bd78380d26175e1062bf34083df0aa994cc5bf27f7decaf0b826675c7651e583efffa7d014f1654209f19ee63198f5de3f6ed9e579adf2f6f363a67e1bec5b063cf25e00b00b028eafb47caa75fb8052381f70ea8c50fa9f557074fef975fb9a1e86206aea30a3e1da96da9060539a0c44ea74c82cfc0077c18ac6de42e974a5fa9ebf27af4cabddc105f06b175de3fe48fbe1282dde1ab9def4d9c1dd3e13f26e46bdd42fdd42dd1a7723943639a909d1a95579b154ff2927e81f174c170c24f0743ccc958e147caa50cff9138d723d30ba631de7d4ffcf1a9fe5eb4d2fe8111b42ce22322e9362ee5ab7bd3b3ab7944c8fb4a09db9a4520e2e39238ce96987b37ad6b14b593cf19282b14f96365e221abe14d5a1e209516ee6a017645700d3760010ad4a0fd21d94dfdf57d8fc146d3a7b0b0a84d5aa921eca30c90bf4eab52e4a9dc17656bc1172af9e9218ca01f44a4eb346b1e5ec8900b729ba09aae1006f742f5e8af55120dddf7d0b70eeccad33532f00e3c1301b8cfff49141be93fa7e3b5626dedec8a99dba20678cd2ee34ea5e6b28cf5599ee86f5c181556bc5df80218bfb3dfcd031454fc4f74019bec1f77353a13556a858c6e1b2fd7b187b79979b593056b8d1b1b4c09f371e52fb79b6c93cb6aa6d0e04ffb1e9fd02c0fc949b62e87d700638cc44993a1a60cce3d54d4bc9bc3c1dbb6f0cadfc721a138bea156451ef43ca65e0d4440c98f6c6b334247882c52740f45b9944286c482189c26c09d6b12e1c0e83fbfaa2bd91b6ce22d1a40d4ac7495064006a1174bb6d75e944b002fcd982a16c126410f27233f5394a7ffd68e42312f32e037c104ae317a3c6baa826c361122590979332d94eba08b9ead9b738a2d6b9a581272b5d5a52cc3920142bd764e6f7753693c4edb4c40bd8a89f6ddf262d234eef33b2a0c851dc03bb6c37488a0c418d280415782292996d05b95d2b62ee38db094fb7bde6aee004f3c3b0f589b90bf327a30a63aa3d8a7fc0c36903e6f86c6ef67222b00d2d0c66a6e8dd1ea7d55220f5955e112509a2d597242a40c9eb66499f6f429ee6432e2de1325d013563f1d372ca91ea2c64706f6fc025ba531a792c64f0a6fd69bf1087768ba9e7a1d6e6bd63ff93050d5a5cb75d6d9e2bc53448576cb3968e29d3d7d173eb9ca224f71b52f8bad62d44ad9371dfade36fd76b731cd9a1b6bdaa357184a37d6df36999798f60d10e0e829796f17dc8abd1d66d8f5942068b5f238b984aef7a72550d142c92fc056156a7a3a97c64c98e159b6f879324c5786a3a2b29b50537030c6d66b33d22c4d3b4e8c4be851bb95b0151d704ef3dfe181cbc241cf8135e6392103df0deab19237dcdfdfb9404ae7b63d4adbde55c9735c1921411e7c4b0eb1e7930a6e7d7483f5e285d7deadaa77a77546f444e50b03571da663487902db52740ec4964b43af60fb2512bb0fb2643fc13cbf3592db9a5d21bd05994712329e5779f85200c6f2c052c46540ba99a9695397c9fab16ced5c0af5ec059de347f1dee2858a0a6121f53cc26df2808e2049ca3eecae9b38e0b7391ae1393dd4551aa8e0b7b6c3f663dde68075399777cad6ab02259c9796101b8343fb540081d03660674b0f31c9a74599b38116b1fe6325a1ae21fd98dad31ac257420ed8c6a0bde236b87ed2ec87f3b67cfb408804614807166dd0e92df7d126abbafd68835a5031b1f6fc26603dcd6ef9361c2fa5b8f367e99b341f4c4c4b57c98839f9110bf4a68a22d9e64c5001847f299cf0c3bcc16769b71f0574c34b149631725eed637f0f14066f098cb374fdd05080ce87243fb2f28e2b966b924536928e3be374bff2c249bb3e62d66a64300ceb32b43f1a8088b9193ab99a9a901f13c161524860bdad6fb308538788043732e7d25adbf15f175d6a668432526fb5873b9ea0c670064928566d7be00c51e52303d77fdf9468ec35ae206c9311d63bc15139a9e6a3feec8531c5d7e03808cf9c610d99b49b0c30a1ead2dc5d8e2cec0536e615d622e451ad05fabd0ca726ae86a24a05ab3773e9d7957473789adc75e523d0b9f01dd518a2666341f13c7adfaa8bbf2d5e7ce0a491a983de41c54006fc7e2ab47439004737ef69a67f581ed2b8989edd80ecbb77b5b5e31820f1643ba18746e29463b16aa2e36f70bfb5ee8dc156ebfba47a37ec2b6914978a5ec57e5807921515f86b97bacb150c376574a898f83c6c0982402d0ef2b63a9e6d60adcda6b120365b10b8074ab9603b98df6fbdc4e3626472088ad4f73e8e51166dda5ea66a06672afd31748bfe3b92450a2fb1f72ffee852d02fef2f69295a0a9640d7b048d2146bed3f8231c9daa9bccae53087f1c302ae91de06d13d9c2b4d2fffc144e1cd2acfa63bd9f3a5c0f1a525808146538df3e14d8775298bde276eb0b3c62b2179056f96beeedc5a057d1e7a5ae709ac98340c8706fa12de8990939627a9ee0be9721463820bd35f8a56f09127d94ecea7418e741f22ca97bd4bdb7e4473d75cb80ed7224368011fd619519a70d86b0ee177c3b40a6eeb6509efc218defe9bbc0d0c8e74f90eb8587a6209b82248f295f3622212a14090f981a95681f7a36d03492391b6e83f12bb8bcb1b75cdb22906a72c8e2ccf4b66b4e1a642ca66bba84cbb051e95b029a7d7c9f8f727ef560c2c3e336d1867810ef93cdc21dfb1f450c1a0777a48104acf4f09511e8a2fe82d0f0e3aaf4193104a987ac3984627d3f4ce6091cc76e4b206318b9215c6edd75834ce791f3f14769f908d97fca816e4a2d25c298e6d72fe52ee3865f047b6bca46c7a5a6f2b85ebd5c02d0bf11994490de8a46cfed39decead184e2bc2d95301b6d53db2c1b10fa482f3a410ca71c29fcc1d01f212cdda3733e0bcb11a036f3b32bb0d038718c8afecfbf4a88b66c93b7a9d65f762a84cdfa01d4ee87ddaf68ea6db984186da82594c08012fb91474a36a210ecb03ce0d36f44e916930088f5895fef564d392bb900c00546d816fb6c4b2a9149b03537f8a753387bb76d6c4cdd1a3a3da25909472c4001795c2e6a4183546f450fc232f84df0b7ebc1216792d04af1ed90fc101a32c5b29bb99b756826ca2b28e4a714271d903ee931e233c3ff53da9fe13eb0a423b70e5504ed17ecc54cb0bf8f4e5c3c4e9e76772536b03497313541203c4a96b45438bc16b0189888df34c0366ae8cc6d4163b8172311b74b6e4744a592ae4be85812903ed8875b1281f4a0e7f5c215bf7fb8c1ac774e767d44bee153c3150e509176558bf563320ce75fba01c155bfc19b6a3a587fb8e76deebcb1e551ecae5425876535a836b770e8870833588ebbf9991ec6ce1d1b614e863ea46593f8ba2df400f8bcbc084bdbf736b074926b186b220f0afba89821ae454066b8f2290c28aded67584745feaeccbc96eb82d2cfb74034cf270fda902920939331000293b49f9ef97d7a9e2a1b30753e8ac974e501b0f9afd51b5228bb5c79f33ac0300b4a843d5c383e8f30e267ca486dc1fdd0f9d648e37468ef346c688aebb8c9b036d6322c3b14c6c6a6daac81b436856a5f8287010569ecd88335bae4ac26eb36a59abf961f6c78301690dcba69304c57809026e5f888f224480b03e0f09f5215c606133cb23442f6512657156d193d7519a844b63feee2d7eb5a810d759f55533db908a0b7810569b64f48536f0f08be7c35d6c8b575a4063e8268739098171eafe31e8b8a9136268499af6773cc6bcda3fc92799e7a20c15c6ce1801458716cc0864273341c08fdc19c2390e16717efeecb635b314733a9770bda3f04d2299568eba0eaa3850dce13ebbf41deab9087f9c81d601787e6edd253e67f927d66191fcd93d0b4b8e70b5d89c256a16dfd13c96608d5560c6c0913f2be6cefc267e9a04bd2d91e1dd4d2afd09d3814ccf8c32b79bdebc96c45699f7eb4c8885550b2759a89f1f6b81553df511090b1cd5e68f9067b58874e2e46b543d75856dcfba62cc2d1aeb1010b49f6bcf003694fb41a00c3bec718feb8f844598c30c08cee5818a18754f1f93d971b98957ebdc7fce0278363263d246c7d14cae935d28837cf7cd6e3ab4184a09cc868749bb2651c4f7bf87df070415de1414e7a9014af62fcd4c5ef48cf65a59af1598ffac7dd71058135a7254ee1bb8df3300dff0056f3cfc4962e71a8781b170e0a097971d2582b85ec0c8027a69e4f055800638d176daad231a8ccdd0a769e113aa5f6240bc71b1e2906c5ddb0f44b89500049708555098a7d08c60b297d1c7bb63bd4aa4beed03199023a189ae7f48d18a2bf7260586a7639349db71c03315722de9a9f31f9aad918fd882c520bc18bd700f589625091588657094ced019b08c3e72ce625f8ebaab5338e882115a000b13bb111238102e3cccf134aeefaed7a74370a5bdb8cdf6f75e17c35c462417405a96ca5dc8bb53e0d16ffcd10502fd4339df9f7d00de2da27fb284fd39dc6c7ba356c3d321542729df04bb09f6fd0b5487f9d47c0af46d0ebf638a711f2bd77988919cc23f5d2eb64d3a13fc3b669617f95b3a4697dacaf9efc89b50491242398993ef99379ba58c3d8295ea2d5303024d8dad62016142f3bd4d6058866bc09bc3311c849d4d99c1a04e8712a8d5ee3ab6490d7392fab4ba34c5105c5abbda50639ced69600b5ed9d35f841d5fef9ec0c0b1d07b735c1bdb1cdf07ff1984bdff8e0429682aee2b4a29e1bc64bcdd4bedbb14e52f91640321f77a246bb19574c9b3ca609c5dfb15ffe1ec0771ab13523d167865d301243062fd5d588715163d7380790252a95d4b68daeab384dd08d2dd2cf91b1690b80e6aed298507ddc4c4515076f478704583375e53d90b46802559cd14cd3ad4fecb39c1c214e0375922e7ec89fe0f3e8406eb7cfeeea2650ab906edec086a984b0e56e7b1c33bb07a194b6a1b41ccb655965d37e7f2c63183b6dea413301d425d3038e957389c11e995a3444bd60bad5f18e941ed7586072d3de858b4403fd14c625ad368f08520e549d9e103ea0002119330b30aa6bf8dd5a9cd8ac4d1e75c95d2fe92abb30e3366bdcf7c3e51c473780f9e0e85f104cbe49e7b1e323c638e8e19292b4d3637f803a0975707e89fbb1e285ffad1d772c99eb83b3a452f49a5b201bf996a2c53f649952780f6aa6aa4b6a0cc2dd89184d5aac57627f89e3764d11fd9fc483bd1a3a520f296a92cb9ed4b986ae1fe2761ab6d3b4b6a9af18c5ef2664c45fd036e112a85e308b907c40f6e0da6811e57a97d71de19647a07b137fc1ca5cb30f5374bf51a2e1a378b95db09ed194b5f0c0ef67607aefc7bc786614992035e9fffb7d04600da1473f65073d7ad1ea75ee07be228eeec96aaee022cbbe9bd787288d744a50f5e6093895af5509713b1259f3eb1aa32270b8d659f674d3f431accaaca8bee9903197cf18dd0af2dca86729fe9290a0e4a99271eb6e3d69b2022857929003fefb5384b0b7d5b86a5fe627f6c0ad474e896c69b6debf01392b0736e7d800498f64139605ebbe1e74ca0a40fb86a5c52187b34ffae4547d17a79260f22b50641a3efcc4ffc8eaad6423d2a1f29172ddf350e0d8b514bd18c4556a8eda077617bf50d7ea3a93dc0fded026291950e74191b14fb5c1daba9b6609ed288d5d54f87189e5a6de6367bf6427db2ecd7d4e3ec58873292435608da68bb5207a04183b5d0a7070b5babf9991fccc28caf1c6e0f6f4a8be68ff810a739861265602a477da41d21cbddb52be072a4027f07ae35319ad4ae303d52c31512677c7ed27873543672b9211aaad5f01bb4af7c397f967403b001eb741fe739147b86db876092d653ade025962b3e30d2d79c5cd7f524e2158746a422aaba2ca91616202e174c9e25b0562f17840810c4745db707f77a044a36860971f2a27b26dde7c72a25951578adb31c36be0d5c97ad7a62f2e7303a055cea004a7f1f61c7d51544a6f50ddea5df47feb9178df9b3fc48097fbb1e6a1a1983a8342b08bd2cccdb66d6a4e5d4f1a5b6983312aea11ea5432539a65432c7fda242abd7a4f293e43a7414e50f2eca458b042da1aa6fac2642edefe50403927efdac5bef3d891e21af33505296b61875f80646537e3846c80060357248a088fb5a0834267fa2f3412187e81a303d42f8faf00d14434e51d53cd8fd39e076cc492072fde76c9a80613af961b8f7e821cffc7048adb4d5fc49d556f798f85f936b83edbefc7d555a7f04c82db6c755a663232f10f6fbefd5b96cce77b8978604390dadc8e446dd7914bfac1721a25da080e4901cfa4f8fefd2e2932536a42b77e5374d03029c53d752b4b0049adf6dbf93c4b464b12226115b3240bbae03c47d6d2e60e4be14773fa43cf627d6cd7893db2b07a7a0d252fb8799962a86e0b5ef6f88a081cefb532792a10994bd8576a7b082e1c564ff5e5c9bfe4bfc945b581acfe6838514083afe26f146383d64cd56902b6512dcfda84995893670af79186b023e1794aab12b4daa0a7e44e19ee61e97736cf85b5d8a5e7cc86a3384ca143894a2a1b2772c8ea98c1d4749a45823bf1d9a9a14530a3ad6e703e8ddb7ed6d1cee13d1c4b7085679c01f7da0da4036fdbc004436e1cb0008ba2500593d4cc2352e0e73ddd1596ad3943deb0f17250ba9ef1445c2db864e511267488f50781c914325d0b3c42635b4496620c483d3909d019de48ae67884e146f1260fd194b0c156de9290df3649e49a57702293e34991d081bcd27670ba287237fd9948b876e9a6e28a810e92e9d69472a53b8bad21aad9006ec17f1eecaa20349fb890cf8b95b484f4e8642b52b1e94f299eb6327cfa932432074259bec2f933e3a438960e71bb5f63433f6d3d872978ed9a36900f6142a3ccba22a552ce8d7f9b9910eaf505b24b6aa3a06b5dc3a688f637fc30872c95eb30bfbc8c03bb8e80b9cfe35120b19687f975037fce9c13aed82f92f6584a46702319b85502e76d0d1f7f25eea30f3972227f977a1b44805a1a31123f3324e5affedeaf6fe7106f82c5e933c5ce4f2206a7e1bd7541dafbd4b464ecad623e42c34ad73e0b8be3be5cf46673f918ba0803af30ed8b8bc34950c51e7ea8d64d7eb08d5f3aa14f86d782134faf8cb9dd058add3d9f66e7ed8ed6c24ce509a501b93cec110fe79eef585f08417e3cfaceabc9043bb1daa39095a14f2dda9e9b591d6d1d011963e3af11dd4c91f02da69b1791d60c294b4ef4ad87902db4b93fbd6e943b43d043bed8197101afdae2990b9bd2a60f296e5ef921bb5be248cff3a1ca27bb617efa9854a03a6ad530ab874b8c183b31ca754932557d060e08a532e0ec000074444e1d5a6b28aa270f72be1fa44826c461340bcddd0f6f3b0674472d799d747c1dc016ff72c3fbd709a90add6d3f8bed70659faba5bc7ca535903b67b89c0a081d95be0bf835c9fbe1bb30555cff337d2d89732f126d0991d2dea2d8dbdf9637ba22d693215dda9d96f919f075322ccb74dddb7ecefc32b378bd50cc97712ece1bb7e6b7e3d25fd3b194014d1563ef9d1c3a4bb87862a8a4312dcd10153515074056c47948117baed9ac59e233263f6d2f63318b632acd029fdcaf77d0ac8b06a620558b973bf0aa2d102174945f5bd5302554dc963b5cc4e62740ad40a78659fcb86b35e13b570277674d6814f3b88c99a72e7fdd369dda09a05db7c1149d213616ca077a1f76ed8371356db12580413baaeed105c79516a5fb265ce0bf35b829cadeff69c907bba00b80aaaa38925ca0d2633aa05f3de08a592e3af293a9beb7a96c5c7f3ea795df6f944656873d3904937e3fd24a84523def182276b824ce9a56f16e563627bf2dc27e82a57822c2314192d3aff226a841357661b3e716253eb7efca0e02316e1a93066a2e052848b06a0dfc81ef8e03778915be1e6c06b5e4301dfc02ef7df98a0dc7eebbbf5576f1109badbf743b9e982953982d1441e0e436d551ceea6ecd24b212d6305970efe0ceb2a6a27871a8119c641281cc33e560dae2b97159e6d2d3ef2bca3b9380fb71f751aea11dd56f9000d4c533f7e3c67d0ea363aaeb4522ac935135de1972d7e35119f524c26ddbec1e22f4487c184368a7f65d7c3408340d1b00e27d0585d543f211a02e2ed9e20f54798efb6bdb818fa51c5cd96498ac19386f17de4d7db536bad7935eff6bd2093e1e25724eb1992ac4637f4cb7bf98bb26edf3b3f0d10c304ee4c88714ade2c8b7675fbdbaf2511b8b8658a307f181f9caa7e3c73ed243aa2ffcac4cd52036a360d379b3da1da677697d511dfd82d91fdc861536215b869bf48e27c6b8a349d0fa586a17efcfcebdb14ce93de70d224cda723c9c17d082702a0acb1e9a8202deba9c5725c492f04996b52eb119db1d37b5dfcb41c6e60d110f502053a5457e9dc0473560bc8c7630763c4699510117d2bdd7f9212849d5ec4b1723e986a1fa61f738968f0bcb6ca6ec334173d1fb680feacf0d8b955780f0535fbb5c4a47394d9bd5a06394c425860b8f66e75e4a378c4a92505348852eeac9e806c665b00cfea540002a62426d97f286eb0080e144c34cfa61ad8e4422fcbf6ef8ae2188852b3e48a4af400c860622f163e8e8ec9f0706793f6321e42a9d5348c56922df64ebc254dd554cf830e1c8b8925719e6b2d1cbdd35e1f2c48950d291fd73b78e9bdc4e73526492a59c219b1bee6dd674130d1956b21acc52939dbc25e43ed93a6093e1807f8c8e6c94959e3ec9da853f9c76adc60ca4534f7cf7956cab0f6bfdb02aa080ff64619d8102bca74b63e2f80e5ddf2a6ee63f3a8c0d2df9ac5b262e6e2331e51c2be56b1822a8f6c3971e73cacfe7231beb2c71125fcf3b88f5cf79e964c33e11c8d72808686d7358bd5d5224967d7c63895767a538b676a10da922840483eac920acec4951a9731b737dc3c709a64a0c1193e67ae11aefcd4928ff8dc0cb17a81638dfc90f923fde8e97fdcf7ed8c51ab820516ef8a6ab17a7dee4f641bae1031d0c1adee2262298cfd62f4027de8ccc1f45820331e445909e677968136974300e0ef00a6500ce22190a12ca928d498fabdc1a25f5831c636cf0a8d1cbb7052558b465d65c862b997450a731025d4e161bee105c32570aff887cc64cb8bf45bacdfb040ea966c31e0432628713a9645bd0fbb09206fc8170e9d1d631f44384fb2cd544ca57550688ca6ab2bc0578a0f51fe15b2c691ff644c4127118b16c08df31244426ce9b94ef3fdf738220e292782b2750a85d062ece7c746d219813c77538263086c2f770a5aa5c6420f4e1f3cbf378f4af73badf36fd3beab9fd0e0d8ae4f75766fc3fe3e949895bb7a785f3e3f9e02b32c29dfc9f3141f1b0f926a6494ad0e743ea6a48d1c3111936ba114e0ca3a0bdcfeefca5985065c87008afa9ac14c07e21fd31871d492ee736fd211781531827aa117fcd1ed662f7fa2c43e1a80536a09abd743a3cc7fdec34724692c9bef4b61bcfe7d715b9faafb44cb91d55cbdf5b1f52bc072bb35042cc766cda986996412218dbc494bd69ee7b7f6908b9849ca225335aa8d030d8168117c9c174437e8e171a2d8f58cbd46da4e8abe4eaaee4ad8141f8d451baabee9b3e3f389443f074cba6ca8812c6bac9f6c1743463270ce540f823bd35ec3b3bb7fd7eccdfb6d1bb626d5bf38ce6521c6e993c12aac1bb42c14fe5ebb525f5584013c39a54dc38b679e16f03017b224a4174ea21be48fbc34e018702ef347751c8cb3258239ee8a1f2fb529177d114309a6242497102d627dc5afbdbfdc7cce23131c1327dc7fa3aade433870e9c2881d05716c8676603132f24a5668a25f93b2fd5577df46335b3f08dd89f8873ce9cb5ed4486dadce6f1f1297ec499d1f74effae8adc55aaf71ad0e3f923473f14797ba2ef06d54973b614498c0033e6150822851dd32412bd015e57d7c6dfdf3c48458e4f2258868a896b5784ea0629d25eb08a4b3c7ee5d172854fbbb879b996f462ce49dbaf3fcbe08e5358b62bf867cf021764d363ce0a6d773b58cce7ce0c0151eaea88cb8737e520054dfcf34f52530a5846be2541bdd8e5b13a793fe8636ce291f7a0bcc4b61934f6088f17a198a791e76c190edfb84b7be1b7eedd215f70b1e8272f376e20c2f37f52e34ed40a56a8adacbc2025b2a96f5bc3b361c81fd3bc33e4eea28557f83049624b61d84f384f05114f3576c800959cff9c93c5b1fbbda88bc0ecf080917ba3b71ad890f11f428ddc766176e4b3e529e85bd38955e518654a4a9c9319d8e94cca201a0e925cdcf613f6bb0712d3191b831e41827a9de14980bd995595d52b24c88e2d17e5698c0d93c223bcde00f0a9db02b5b42e69dac39339b3567d399f3e69f10b58c6ceff9a0a3929d4c7ff48aca2bdc27b95e19d28dbca5a43c4a242ccda89f13f7aca4da002d0c04db50245687444bfadf279b48ab74020b103768c3384e872b822f1cd1e33533b1a286fa4417697812ca74e5ed43cc17b202efc29e569819c38847795892c89570a2b8fe1748c9ae6ad11e26e8f48246b57fa8a4c385b6616bc0f035211d0d522fc59f6b5b0dee7cf88bf04ccf2b2ba3b288b9523b2d7a8a2be58afae89abcf0b79e4dddc1fc86f97bdeaec3e69cc293fb56506cb8e30ce2e05ab321f62bf050f5745defe310da0b1bd45d65d24023273265a8f6c38eb5f7387b54b9b684674f176d83c828b0d05bedeafaa61bc498edcac95b9472b6e5f27eb4f164f9f596de897be26ebf7ead8abcb54ae3cfff10ac91e25d3bdcf5ce70fff7ce26fdbd16711728e825cec598e8c8c626dd4d4c9de8f90f94a2f2f880a844997133157eaed833d9c53c024963c11adf21a6a63d7764bc2f9f3b45af35f6b7cdc6b4c3ebe1855782ed09198ef751cad369e6f3bf1a08c9fa87533faa9fb04969e1da46dfd6cf32c9f222374e22d7176b3759348a015d5989aaebb5424b7c3403c1d6b8735a44888cfe7e7972a55a5fb29038443ba634dfeb04bb46da7283b6654f74890fc8a0f1fd2f03f3b435016b59c47f8f1f1e1b6dc6d1e53fb547792f24f95a0cbd3a5487f8a0b5263b14163c5a761a2ebace3b59fa8a0f397b3499ce7c61016157172e056ffbf56bd1cc024ea3c9c1249b44699d070e5fa8b1f7f4e77ecc84e78c81e223073f2fed012307d4a56ebd62d71e1576dd97a3988b43c78c82f7f67cd9f24d4f75ef2c97c387fea22fb5e159008086a3b565cfdd6a60b37b125da2d5c226a307b5a57e6fee2be877221e2bd3adfece08ad746b3a8011f23fe9646a575112cf1496b4f4157711c203fdc396c3ef8a32c510e39099a0ccc5b1793ea2c1f3e02ea82d152636846d17eeecb029542b8eb8639854fa990947dc1ac76c97101e9aa98bef955f86d25bf505d0d7436c748ecb6c3135e91c45f22b8f01c6a9151b0c52eec78bc196c6113674bbc3e6994854261b2edf9d4fa61fdffdb2b9263a25dc22540e71b9e642edd4b2890f7466a0c3d19b97c51a12d65c5a18e57bd67f60eb69aca937b4b96a82fab4baf99246be2f4db850509050b9d32c74f8e0fd65d93936a6698fdea943c1d743abbb268cbf4898fa4c73a1a6ddf48f856d53029881792048d854eb2b899978dfc69566d07dc4cc1437c05fb8aa8031108cdf38e166f97eec79fa1117a798d3c6f19fd56d6fa87042fe9215e60fe0c772290c58909d1b4288b7c7436cc273f02a61c4f946ada9dad4872e53c92d1e26845ed37e5288a505aef720978db1c25280922e440b44206064402cb218c6d151c3c0696cb3fd058497bf213087b44a25c1c0bfa4b0ca096e04c5f2dfa6b0f7e0f80826707933d5faad5520231c70410230f7baad9a1270f52b672fa83af115101af7008df71066aad8779ca5444cf5c4454174195de8e1d9949729077d674bf8f81d192a7338d3d70528766280a8ecc0d42c91d84e208d10e78253cfa3f112a39735bd0b410ec847226e772946879a828e646ad94143a0482b7272d90f928f04d3fff5d4ca0cfd5c8ffd8bed4dea56241d5d392d1291a534d0714add0f2b66a474bb20f7d02e5bdc2cd1c06ebf7a1d5a9d932e39f35667e701cdeb7fc2222d3c577a1aa787dd3f47b88dfda274a4c95b030f644b8732b7054a28a7c8174ff69733bed66e3b8cb8bde475384bcf4d076f75732f9b305ddc18fb65f1eba98870d2ad57b0155cdc913d56b4de573f12ad53e1423b9dbe95575cb08381525802e32bd3550204d0e9120620b39e957cbaddf4567860365ee79c720fd60c792e01c587b52334d9bf9b5f1b6a8f40b606ad731c226de1a82888a7451f5ee8b76d828aa24a392f9df6d75bb9f6ef2037e2b025b80d086a81f179231f99f493bffdf89db6329cf4ed0286a587680c6841d2d5033663e31e961184cfefe98eabe3be6751c26ebba127d9211d8f5b3864a0afddc650bc5a2c7df7e1f1026eeb43638d350488106a94b136dbb5006ae0018b6a48d5597b81d118b049e14d5708aa29fd6decd9c91fde0dbd1c1089c30f296d7ff3153100e2f46254bf24dc42a0b8f2177f2d8567936665908a1c3635936a1c1906f579ad59584b0bd6a7067ac9a8e0930dd3dea7e8e120b787f69c8f24fe49d53c233083f3f6850af67a18341df656c768d2e974e01dcd480efc80253a223cc018eeafd81081ab07295066c91d54ab353d87b5f7ae155e594ecc970455887ab783891309897465e9b30eb28c0d1a9867bfd1b0a87edbeb526c50102cda5766b4a1746a69ebb23eab2f1adbe1b4a2579b3b3a17663e323981eb5c0982b62ed52d134dac99a9f45cd2673e08eabcf99babe7e2c525f32f7d52fc6f4e52a5db007f958a5d606ac2de131136d1aacb38193dd4a3cb0472e995c9484c8dba0250bbd19a3a23a4f655f047f12142c7dc4394f4629f23ce2e308e7359cd127095d046789e3703295cf4873c2b31d31272dd80851f42f63ee2e618af226d470e63503fc204695e95a4cb6acae7f897b154b37188348dea5dcc6508c8f0514cf2ebe4345d032ecfba5c426f22cc54aaee7c806ff56d294d3fd5b456f9cbe01250cbe9b4e4ea58ab3d57c40af8a5427f067d235fce9d4f6dec44fa89b24b82d108cc3ed4703ecf5b11a6d74a38004da27eb60f0cdb74a9202b79d69d24affa96cfb3ac64897c1f99099fc2340d5e2230505e4a5b2c449298ff5fdd1ce4921bea329e401788e36d4f0c91e84c5f5aa8dfd0fc2d8d44f6730b7e4028beb6f29d61c52bca4eb5851706ddcb3edfd5e73745f119a4bdf4d7164836066e3bd3a905aa7f4f4811c233e855ea1b68f41158c3f5d0841a6066e2f81db22a9d34cc4fc849c22717c605c7f12c93dcb162c281058723ddc89ceff488872d6e56d881223fb49630f33080300fddc77e77135a6c6c21aa023fd794967b6a55bc7aa13e228ee31099d551b27bf74df2a983f307232b8e7127af39d397c692d63176049c67677799e7348f915018840b5a20a94f03a7cf308e602a3379e433ee853b59c1ea6c12fc3e5f8b4bdbe61503cbf6976d106c523c7097a5814d82b3076773d17cc1294b239a0359ce2aa0878ad81a7bb59574d22c74059be6708a7da9af9d2ac4f2d937bb345b9af2ca34c89aaa1fc6218737e30412ceb30d1cfc596302e1a56f1d6d0375719cbc154952edf878e6bb2b88c87b8f6f567d02ccd4b662e8b7de27aa7aa1ee8780beaefd7de8f7195391fe460823a7a132865667cb736a751b2b40fcd8b3abd530b031e7e54b845c23c7b82825254ce5aa7965b6947c3181fa677880da368ce52782ebbe3937184504cadfd84d77c9ca74e3a02fef0d43c021c403ed3c6ff665ef35eb7d3df73dab490bfa68591bfe83f40a8010f6730e588341d2df2d9fb38182c7189ef08b5e24bbd71b9c2f55ce6e9a7ebc09f5197583160199ca64bf1b242dfe6f4f9f2124908d6b302a26f02cabddf56a71c3ad10e42895b6bf5a9921abaa1d6b3657849ec5be32d5129c664d61ab786392e963707f72f8fcf7bc9f2e8ee026aa7fbcc1de3f7bab922cda613b7b3f085692c6f5b9013401cd53dc5780c2de86d6d7127621bcdad1b2ed97d1e89ca93c9418e2e48605ba61a8dba442adc36d66cd3fac8c7d789104aee435ac45c4fbc40955a8597c8efd82b5dd7534500f2fd81fb85043287a507feac292f7bfab8d389467cee88e685a3817b6fa12372a6fa967ad0efb2a957e70013ce859574478c4d6ccd31dd4e26709c762e70c21890b0d5829b74f7ef251c80d71dc13337467a5529b56c67c60e992142e0b97ae97067246f03e64216a0f9c5ab4a354f77af1fad91af07560a7af70ec3bc4251456ccf89d5d09add206a69f66e7a9fe374b4f37cb4685e429ec666983becab93c742c6d2c2ea9e32a1d43d8036b8c06d90d164f3db0a9c95d7759f8975983d8eeb30110ad3ff03979b404c8d7172217e2df1076e0a667e8983fbe4913ef95322ae04f1cb5d41790f871cbec4f64358351b7b7ded7d4a8c835dfb7cf2ece4c0056e78f282b0c56c7b0f6b148f0441f1efe4319f9806e1e032d9860965da91acde866f9ccaa5ed1843217efc86dff35f0ff5f434dfce965ab04e4f84358c531c0bc05404cd8015f19d53d957a0e35a6c1e0c27f6915db09cd17a9766f0a6f19cb28793b58dee2190fbb451fe1c38a6b3dff61596ba2ba8cf01a268832b830fab2451f334eab1279e1dce5a1327021c4cc9c372e5775a6b9a0a0ddf7572bf366d101645d2068910d5c425a0582ad65076fbd370b70b5b4ebfceef7979570938bd22b3481fd5da3cfa2f3ceb3184f333b7e91bd7e2905f13d47c16febf6ff841980fb9a3045210ebf4ca1371200535be97d3a4f61e539b69ead711a0c8eb2ca1cd8067d044b4b338a85709fff3f16f8f5c751e02f517c9a7dee9efdbde19e1a90efec6dbf4baa0b4448499baf3c549a348cf95caacadf884aaa5596a4dde1acca96c421dee74b94e803bf9f2b9446e3b230b39433317a20ad483654955b400e469ef0b9a8da9861d00b93ef6942582725ed8a5add11fc507b98c2a4275c9ac8b9c224adcc3b37c3e24244295b80cd2d1788dc31db3d72f879b176639510ef7fa2b566adf6d723e67718f2dde83db1cc52878810babb2f6d7ecaf9b137060b957573bbea3a47fdfcd6a6d7573dc4bfa12d1a63bd863b076900e2d0dd158eaf6eed3071e410fff40fa4f09c9db746e587f953975e9cf074a0af5a2684bc1b836a4677359dca4838dd36255a63201c37c010284b28157f058faa61ed842d3f5f5998969d5980a865a99fa9f7fd5a5652eacf0ccb74902a3c679f4478e38312f6b74fbd9fbfb5e07ecaa006aaddd0b80ed39a8a1215b427cdcdcc506bcf8b0c69e4b2e1f0c552d96da8c0b2a5949ea5d35619bad082a54ed193c44556b7e809104151d9927416a2b6518634d4efb84e8e91544768da422372d9f1cd6a19cebf34a17b18f1a4cbb28b42bc1a6bd462c328848d9087642d86073ee1999d8b88da7a9b1c602f86f332b19407ec1dc9259d0a6494323f9a79028d37ced81dd9829d514243f1d2208cc640c54c6b9726fe2d0c5e1a3a64d59049957f1ed596ec0e5d3b4745073861ec9f2f4d74a3e4e89eefd10b0c31abd1e2f7fcc40ab2980e4ff73b04a45672a32cfdde51e0709d2a7c20133cdfcf7e4cb1e9ca6724ccab1f2b796ffc737e398a0d2cd19e452cb11320b7a9608be9a247788a17cfaef11711b7a8fde4b5eb494e6af1a0627ae2181f749557663c8f356567bf95ea7545965c760fcf98d7a9a3e90a8b662ed32275a997195e8fdb0be40d175050b088438af3be5eb0637c842a0d3b1e6e1540a41867256bc152054ff30a7765b164f12cb558bb98c9fb38d7690249b40c22f80e05cae4e68c44e4fbd8a3e5d6d4aeddcfed93067831be6f6f03f100c61e364f30fb82ddc019ca6b3b77cb15a7060a09124dff2c2c33820854ece4cbe6a35321fffd625d26d62fdd639c3dc614ccf4663186e73247135cb33224a31e0bf67c6833bfa7ab92a7cd9538e7d2cb133162d5abb28c6c8562da3198be56bd5b1d51bbea6415dfdd97fdb32b565c23b92344bea41f0a3492297e8a5ad","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"3ce507516cc56ec0fa738732f387e94b"};

        // Use default document.write (no blob URL)  keeps real URL so links work,
        // and lets Staticrypt's built-in localStorage code run after replacement.
        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
            }
        };

        const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
        const imgSrcEyeClosed = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
        const imgSrcEyeOpened = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS4zIDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
        toggleIcon.addEventListener("click", function () {
            const passwordInput = document.getElementById("staticrypt-password");
            if (passwordInput.type === "password") {
                passwordInput.type = "text";
                toggleIcon.src = imgSrcEyeOpened;
                toggleIcon.alt = templateToggleAltHide;
                toggleIcon.title = templateToggleAltHide;
            } else {
                passwordInput.type = "password";
                toggleIcon.src = imgSrcEyeClosed;
                toggleIcon.alt = templateToggleAltShow;
                toggleIcon.title = templateToggleAltShow;
            }
        });

        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, true);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
